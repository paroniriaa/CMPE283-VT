---CRITICAL NOTE---
All commands listed here are done in a Linux(Ubuntu) machine, so try to modify some steps/elements if you are using Windows/Mac.
For A3, we will be re-using the environment we created in A2 (modified L1-VM kernel, created L2-VM with nested virtualization).
Therefore, if you have the environment ready to go, you dont need to reproduce the steps from #0 to #38, just start from #39.

0. (Optional) You can first download and install GCP CLI tools:
        Check out https://cloud.google.com/sdk/docs/install to install it. 

1. Set up free billing account using the Google Cloud Education Credit Coupon 
        Note: Much thanks to Prof. Mike Larkin and GCP Education Team, you guys are great! :D

2. Create new project named CMPE-283, and connect it with the billing account created in step 1.

3. Enable Computer Engine API, wait for its initialization to be done.

4. Configure VM Instance on GCP:
        Go to GCP -> Compute Engine -> Virtual Machines -> VM instances -> Create instance:
        Name: Instance-1
        Region: us-west1(Oregon)
        Zone: us-west1-a
        Series: N2
        Machine type: n2-standard-4 (4 vCPU, 16GB memory)
        Boot disk:
                Public Images:
                        Operating System: Ubuntu
                        Version: Ubuntu 22.04 LTS (x86/64, amd64 jammy image built on 2022-12-01, supports Shielded VM features)
                        Boot Disk Type: SSD persistent disk
                        Size: 150 (CRITICAL: 150GB is not a must have, but you do need HUGE space for building the linux kernel, so go for the MAX you can do)
        Identity and API access: Compute Engine default service account
        Access scopes: Allow default access
        Firewall: Allow HTTP/HTTPS traffic
        Note:
                Nested Virtualization: True -> this need to be done using command line
                Min Cpu Platform: "Intel Cascade Lake" -> this need to be done using command line

5. You can save (not run) the scripts for creating a GCP VM(click on equivalent command line):
        # run gcloud commands either on your machine's shell or GCP's cloud shell
        gcloud compute instances create instance-1 --project=<gcp-project-id> --zone=us-west1-a --machine-type=n2-standard-4 --network-interface=network-tier=PREMIUM --maintenance-policy=MIGRATE --provisioning-model=STANDARD --service-account=558940717781-compute@developer.gserviceaccount.com --scopes=https://www.googleapis.com/auth/devstorage.read_only,https://www.googleapis.com/auth/logging.write,https://www.googleapis.com/auth/monitoring.write,https://www.googleapis.com/auth/servicecontrol,https://www.googleapis.com/auth/service.management.readonly,https://www.googleapis.com/auth/trace.append --tags=http-server,https-server --create-disk=auto-delete=yes,boot=yes,device-name=instance-1,image=projects/ubuntu-os-cloud/global/images/ubuntu-2204-jammy-v20221201,mode=rw,size=150,type=projects/<gcp-project-id>/zones/us-west1-a/diskTypes/pd-ssd --no-shielded-secure-boot --shielded-vtpm --shielded-integrity-monitoring --reservation-affinity=any --enable-nested-virtualization --min-cpu-platform="Intel Cascade Lake"

6. Run the VM generation script on step 5 and create the desired VM on GCP:
        # located A2/scripts/, modify it before you use
        bash gcp-create-vm.sh:
                gcloud auth login

                gcloud config set project <gcp-project-id>

                gcloud compute instances create instance-1 --project=<gcp-project-id> --zone=us-west1-a --machine-type=n2-standard-4 --network-interface=network-tier=PREMIUM --maintenance-policy=MIGRATE --provisioning-model=STANDARD --service-account=558940717781-compute@developer.gserviceaccount.com --scopes=https://www.googleapis.com/auth/devstorage.read_only,https://www.googleapis.com/auth/logging.write,https://www.googleapis.com/auth/monitoring.write,https://www.googleapis.com/auth/servicecontrol,https://www.googleapis.com/auth/service.management.readonly,https://www.googleapis.com/auth/trace.append --tags=http-server,https-server --create-disk=auto-delete=yes,boot=yes,device-name=instance-1,image=projects/ubuntu-os-cloud/global/images/ubuntu-2204-jammy-v20221201,mode=rw,size=150,type=projects/<gcp-project-id>/zones/us-west1-a/diskTypes/pd-ssd --no-shielded-secure-boot --shielded-vtpm --shielded-integrity-monitoring --reservation-affinity=any --enable-nested-virtualization --min-cpu-platform="Intel Cascade Lake"

7. Generate public and private SSH-KEY:
        # you should run this only one time, then copy your ssh key
        # located A2/scripts/, modify it before you use
        bash gcp-gen-ssh.sh:       
                # define $USER if needed

                ssh-keygen -t rsa -f ~/.ssh/google_cloud_key -C $USER
                
                cat /home/$USER/.ssh/google_cloud_key.pub
        
        Note: If you have terminated a VM in GCP which happens to have the same external IP address to the VM that you just create
                you will run into host authenticity failure which blocks you from establishing the SSH connection between your
                machine and the host -> because GCP reused the same IP but different ECDSA key fingerprint(public key) for 
                different VM, so your known host info recorded in your .ssh/known_hosts has a mismatch (GCP should really fix it....)
        Sol: re-create your SSH KEY using the gcp-gen-ssh.sh, do step 8 to add the fresh SSH key and delete the old SSH key, then
                you should be good to go (but the price is that you will need to add all the host info again when connecting :C)
                Also, remove your known host in your machine:
                ssh-keygen -f "/home/<your-account>/.ssh/known_hosts" -R "<VM-external-IP>"

8. Save the generated SSH public key to GCP VM Metadata:
        Go to GCP -> Compute Engine -> Settings -> Metadata -> SSH Keys -> Add Item ->
                # the format should look like the following
                Username: <your name> (it will get auto generated)
                Key: ssh-sra AAAA.....XfGI0= <your name> (just copy from ssh-sra...to the end)

9. Connect to default VM instance-1 in GCP:
        # located A2/scripts/, modify it before you use 
        bash gcp-ssh-vm.sh -e  -e <vm-external-IP>
                # define $USER if needed 
                        
                while getopts e: flag; do
                        case "${flag}" in
                        e) EXTERNAL_IP=${OPTARG} ;;
                        esac
                done

                echo "Connecting to VM $USER@$EXTERNAL_IP in GCP using ssh..."

                ssh -i ~/.ssh/google_cloud_key $USER@$EXTERNAL_IP

10. Clone the Course GitHub Repo to the VM:
        #check screenshots/VM-gcp-ssh-vm.jpg
        #check screenshots/VM-info(uname-df-nested).jpg
        # Your GitHub Repo should contain the initial files that provided by Prof. Mike Larkin:
                # 283_Assignment1-F22.pdf, cmpe283-1.c, Makefile
        # your https-based GitHub Repo looks like this: https://github.com/paroniriaa/CMPE283-VT.git
        git clone <your https-based GitHub Repo>

11. Install necessary compilation tools:
        sudo apt-get update
        sudo apt-get install gcc
        sudo apt-get install make
        sudo apt-get install flex
        sudo apt-get install bison
        sudo apt-get install libssl-dev
        sudo apt-get install libelf-dev

        #This line of command may not necessarily work as $(uname -r) does not guarantee to give the 'right' version for your linux-headers(such as WSL)
        sudo apt-get install linux-headers-$(uname -r)
        
        # If failed, try to use the following to find the right version of linux header for your machine
                apt search linux-headers
                ls -l /usr/src/linux-headers-$(uname -r)

        #---CRITICAL NOTE---: 
                If you are using WSL/WSL2, you will not be able to find the
                corresponding linux header because the base WSL2 kernel does not
                allow modules to be loaded. You have to download, compile and use 
                your own kernel build. 
                For details, refer to https://unix.stackexchange.com/questions/594470/wsl-2-does-not-have-lib-modules
                Also, here's the WSL2 kernel GitHub Repo https://github.com/microsoft/WSL2-Linux-Kernel

12. (Optional) Install GitHub for ease of use when performing push/pull to the Course GitHub Repo
        type -p curl >/dev/null || sudo apt install curl -y
curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
&& sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
&& echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
&& sudo apt update \
&& sudo apt install gh -y

13. (Optional) Login to the GitHub account for avoiding multiple auth prompts when performing push/pull:
        gh auth login
        ? What account do you want to log into? GitHub.com
        ? What is your preferred protocol for Git operations? HTTPS
        ? Authenticate Git with your GitHub credentials? Yes
        ? How would you like to authenticate GitHub CLI? Login with a web browser

14. (Optional) Install GPG for GPG key export and commit signature:
        sudo apt-get install gnupg
        gpg --list-keys 
        gpg --full-generate-key 
                RSA and RSA (default)
                4096
                1y
                Y 
                <your name> 
                <your email> 
                <your password>
                <your password again>
        gpg --list-keys 
        gpg --export --armor <your email>
        gpg --export --armor --output <some file name>.gpg.pub <your email>

15. (Optional) Configure Git global properties for auto sign using GPG key when committed:
        git config --global user.name <your name>
        git config --global user.email <your email>
        gpg --list-secret-keys --keyid-format=long
                #sec   rsa4096/<your-private-key> 
        git config --global gpg.program gpg
        git config --global user.signingKey your-private-key 
        git config --global commit.gpgsign true
        git config --global --list

        # commit your code by the following
        git add -A 
        git status
        git commit -m "<your commmit message>"
        git push

        Note: 
        you might encounter errors like:
                error: gpg failed to sign the data
                fatal: failed to write commit object
        you can fix it by:
                export GPG_TTY=$(tty)
        you might want to make it auto export whenever you initialize your bash
        so you dont have to do it every time by yourself:
                modify ~/.zshrc:
                        GPG_TTY=$(tty)
                        export GPG_TTY

        # check your signed/unsigne log history easily
        git log --pretty="format:%h %G? %aN  %s"
        
        Note: 
        In case you mess up something, dont worry, heres a trick for you to revoke commit using git:
                #n is the number of commits you wanna revokes
                git reset --soft HEAD~n
                git push origin +main --force
        In case you mess up on some branch and want to force sync your local branch with the current main branch:        
                git reset --hard origin/main

16. (CRTICAL) check if the current VM has the nested virtualization functionalities:
        #check screenshots/VM-cpuinfo-0~4.jpg
        #check screenshots/VM-lscpu-0~1.jpg
        Note: This is very very important, make sure you check it, otherwise all your following works will not be valid :C
                If you strictly followed my gcp-create-vm.sh shell script, you should be fine, as we explicitly configured that
                '--enable-nested-virtualization' when creating the VM. Still, we need to double-check:
        We can check using the following command:
       
        cat /proc/cpuinfo

        It will show detail cpu info for your machine, but we only care about the field 'vmx flags', so if you find it present
        in the cpuinfo, you are good to go.

        cat /proc/cpuinfo
                processor       : 0
                vendor_id       : GenuineIntel
                cpu family      : 6
                model           : 85
                model name      : Intel(R) Xeon(R) CPU @ 2.80GHz
                stepping        : 7
                microcode       : 0x1
                cpu MHz         : 2800.296
                cache size      : 33792 KB
                physical id     : 0
                siblings        : 4
                core id         : 1
                cpu cores       : 2
                apicid          : 3
                initial apicid  : 3
                fpu             : yes
                fpu_exception   : yes
                cpuid level     : 13
                wp              : yes
                flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq vmx ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 xsaves arat avx512_vnni md_clear arch_capabilities
        --->    vmx flags       : vnmi invvpid flexpriority tsc_offset vtpr vapic ept vpid unrestricted_guest vapic_reg shadow_vmcs
                bugs            : spectre_v1 spectre_v2 spec_store_bypass mds swapgs taa mmio_stale_data retbleed eibrs_pbrsb
                bogomips        : 5600.59
                clflush size    : 64
                cache_alignment : 64
                address sizes   : 46 bits physical, 48 bits virtual
                power management:

        based on GCP specification, you can also confirm the nested virtualization using another command:
        grep -cw vmx /proc/cpuinfo
                8
                any output other than 0 indicated that the nested virtualization capability is enabled

        if you want, you can check the amount of disk space available on the filesystem with each file name's argument:
        
        df -h
                Filesystem      Size  Used Avail Use% Mounted on
                /dev/root       9.6G  2.2G  7.4G  23% /
                tmpfs           3.9G     0  3.9G   0% /dev/shm
                tmpfs           1.6G  928K  1.6G   1% /run
                tmpfs           5.0M     0  5.0M   0% /run/lock
                /dev/sda15      105M  5.3M  100M   5% /boot/efi
                tmpfs           795M  4.0K  795M   1% /run/user/1001


17. Note that we actually skiped the requirement for 'download and build the Linux kernel source code' during A1,
so now we need to do it for the right configuration and environment for A2 and A3
        #check screenshots/VM-clone-linux-kernel.jpg
        Note: I took CMPE 283 during the Fall 2022 semester, and Prof. Mike Larkin did not make the requirement
                (that I mentioned above) to be mandatory during A1, but yours may be different, so you need to
                double-check, otherwise you may lose points :C.
        First, go to https://github.com/torvalds/linux, fork the repo to your account, and clone it on your VM:

        cd ~
        git clone https://github.com/<your-github-account>/linux.git
        cd linux
        git status
        git remote -v

18. The forked linux kernel may not be buildable as it is not yet correctly configured for the current VM we are running,
        #check screenshots/VM-cp-kernel-config-file.jpg
        
        so we need to find the corresponding configuration file for it:
        cd ~/linux 
        uname -r
                Note: my VM's kernel release is '5.15.0-1025-gcp', yours might be different,
                mark it as you will need it for the next command
        
        cp /boot/config-5.15.0-1025-gcp ~/linux/.config
                Note: if cp cannot find it, you need to find it yourself, cd to /boot and ls to check all available config file
                and use the matched one
        ls -la
                total 1304
                drwxrwxr-x  27 junjie junjie   4096 Dec  3 14:06 .
                drwxr-x---   6 junjie junjie   4096 Dec  3 13:58 ..
                -rw-rw-r--   1 junjie junjie  20349 Dec  3 14:05 .clang-format
                -rw-rw-r--   1 junjie junjie     59 Dec  3 14:05 .cocciconfig
        --->    -rw-r--r--   1 junjie junjie 261224 Dec  3 14:06 .config
                -rw-rw-r--   1 junjie junjie    151 Dec  3 14:05 .get_maintainer.ignore
                drwxrwxr-x   8 junjie junjie   4096 Dec  3 14:05 .git
                -rw-rw-r--   1 junjie junjie     62 Dec  3 14:05 .gitattributes
                -rw-rw-r--   1 junjie junjie   2046 Dec  3 14:05 .gitignore
                -rw-rw-r--   1 junjie junjie  24982 Dec  3 14:05 .mailmap
                -rw-rw-r--   1 junjie junjie    369 Dec  3 14:05 .rustfmt.toml
                -rw-rw-r--   1 junjie junjie    496 Dec  3 14:05 COPYING
                -rw-rw-r--   1 junjie junjie 101639 Dec  3 14:05 CREDITS
                drwxrwxr-x  86 junjie junjie   4096 Dec  3 14:05 Documentation
                -rw-rw-r--   1 junjie junjie   2573 Dec  3 14:05 Kbuild
                -rw-rw-r--   1 junjie junjie    555 Dec  3 14:05 Kconfig
                drwxrwxr-x   6 junjie junjie   4096 Dec  3 14:05 LICENSES
                -rw-rw-r--   1 junjie junjie 688453 Dec  3 14:05 MAINTAINERS
                -rw-rw-r--   1 junjie junjie  70613 Dec  3 14:05 Makefile
                -rw-rw-r--   1 junjie junjie    727 Dec  3 14:05 README
                drwxrwxr-x  24 junjie junjie   4096 Dec  3 14:05 arch
                drwxrwxr-x   3 junjie junjie   4096 Dec  3 14:05 block
                drwxrwxr-x   2 junjie junjie   4096 Dec  3 14:05 certs
                drwxrwxr-x   4 junjie junjie   4096 Dec  3 14:05 crypto
                drwxrwxr-x 139 junjie junjie   4096 Dec  3 14:05 drivers
                drwxrwxr-x  83 junjie junjie   4096 Dec  3 14:05 fs
                drwxrwxr-x  31 junjie junjie   4096 Dec  3 14:05 include
                drwxrwxr-x   2 junjie junjie   4096 Dec  3 14:05 init
                drwxrwxr-x   2 junjie junjie   4096 Dec  3 14:05 io_uring
                drwxrwxr-x   2 junjie junjie   4096 Dec  3 14:05 ipc
                drwxrwxr-x  22 junjie junjie   4096 Dec  3 14:05 kernel
                drwxrwxr-x  22 junjie junjie  12288 Dec  3 14:05 lib
                drwxrwxr-x   6 junjie junjie   4096 Dec  3 14:05 mm
                drwxrwxr-x  71 junjie junjie   4096 Dec  3 14:05 net
                drwxrwxr-x   6 junjie junjie   4096 Dec  3 14:05 rust
                drwxrwxr-x  39 junjie junjie   4096 Dec  3 14:05 samples
                drwxrwxr-x  17 junjie junjie   4096 Dec  3 14:05 scripts
                drwxrwxr-x  14 junjie junjie   4096 Dec  3 14:05 security
                drwxrwxr-x  27 junjie junjie   4096 Dec  3 14:05 sound
                drwxrwxr-x  41 junjie junjie   4096 Dec  3 14:05 tools
                drwxrwxr-x   4 junjie junjie   4096 Dec  3 14:05 usr
                drwxrwxr-x   4 junjie junjie   4096 Dec  3 14:05 virt
        
        cat into it if you like, its hella long, all related to VM configuration :]

19. build the linux kernel using the .config file we copied:
        #check screenshots/VM-make-oldconfig.jpg
        Note: if we have our .config file ready under the linux directory, the command 'make oldconfig' will take advantage of it and
        only ask the questions that is not listed in it based on the release version of the linux kernel that we're going to build

        # (CRITICAL) install these essential tools before you make oldconfig, depends on your VM, you may need to install other needed tools, try to figure it out yourself :C
        sudo apt-get install build-essential
        sudo apt-get install kernel-package
        sudo apt-get install ccache 
        sudo apt-get install flex
        sudo apt-get install bison
        sudo apt-get install libssl-dev
        sudo apt-get install libelf-dev

        make oldconfig
                Note: even though we have our .config file, we still need to answer a bunch of configuration questions, but luckily the oldconfig
                will figure out the default options for us, so we just need to press 'Enter' key all the way to the end :D 

        (CRITICAL)Note: Before you build the modules, you may want to double-check your .config file to change some content to prevent make modules from failing
        
        scripts/config --disable SYSTEM_TRUSTED_KEYS
                Note: or change the value of 'CONFIG_SYSTEM_TRUSTED_KEYS' to ""
                -> CONFIG_SYSTEM_TRUSTED_KEYS = ""
        
        scripts/config --disable SYSTEM_REVOCATION_KEYS
                Note: or change the value of 'CONFIG_SYSTEM_REVOCATION_KEYS' to ""
                -> CONFIG_SYSTEM_REVOCATION_KEYS = ""


20. prepare the linux using make prepare command:
        #check screenshots/VM-make-prepare.jpg
        make prepare
                Note: if you do everything correctly, there should be no errors and make should be successfully complete; if not, try to debug!
                        (most likely is because you did not install all the needed tools)

21. build all the modules that goes into the linux kernel:          
        #check screenshots/VM-make-modules.jpg
        make -j <your-vm-cpu-total-core-number> modules
                Note: you can use more than one CPU core to build all the modules for linux kernel
                        This is a process that would take EXTREMELY long time to finish, so MAKE SURE you use all cores available,
                        otherwise you will regret...:C

22. build the linux kernel itself:        
        #check screenshots/VM-make-kernel-0.jpg
        #check screenshots/VM-make-kernel-1.jpg
        make -j <your-vm-cpu-total-core-number> 
                Note: again, you can use more than one CPU core to build the linux kernel
                and again, this is a process that would take EXTREMELY long time to finish, so MAKE SURE you use all cores available,
                otherwise you will regret...:C


23. after the modules and kernel is built, we can package them into a format that suitable for booting inside our VM
        #check screenshots/VM-install-modules.jpg
        sudo make -j <your-vm-cpu-total-core-number> INSTALL_MOD_STRIP=1 modules_install
                Note: it takes too much space to package all modules including their debug info, so we will use INSTALL_MOD_STRIP=1
                to strip all the debugging information off the modules while they are being installed, so it is more light-weight
                for our linux kernel

24. now we can finally install our fully-built linux kernel to our VM:
        #check screenshots/VM-install-kernel.jpg
        sudo make -j <your-vm-cpu-total-core-number> install
        check 

25. (CRITICAL) reboot the VM to have it boot the newly installed linux kernel:
        #check screenshots/VM-before-reboot.jpg
        sudo reboot
        
26. (CRITICAL) now connect back to the VM, use uname command to check if our newly installed linux kernel is loaded:
        #check screenshots/VM-after-reboot.jpg
        uname -a 


27. (optional)Try to compile and run the initial cmpe283-1.c code and check the boosted linux kernel output of MSR discovery(IA32_VMX_PINBASED_CTLS for now):
        #check screenshots/VM-nested-kernel-test.jpg
        
        # the initial implementation of cmpe283-1.c should have included the discovery of IA32_VMX_PINBASED_CTLS
        # if you are using my version of cmpe283-1.c, it would print the complete MSRs discovery
        # welp we just gonna compile it and run it to make sure our working environment is compatible for A2 and A3

        make clean
        make all
        # if you are using my version of Makefile (recommended)
        make test

        if everything works fine, you should be able to see something like this:
        
        # Display the kernel log
        sudo dmesg
        [  169.300446] cmpe283_1: loading out-of-tree module taints kernel.
        [  169.300480] cmpe283_1: module verification failed: signature and/or required key missing - tainting kernel
        [  169.300722] CMPE 283 Assignment 1 Module Start
        [  169.300723] Printing Pin-Based VM-Execution Controls...
        [  169.300725] Pin-Based VM-Execution Controls MSR: 0x3f00000016
        [  169.300727] 0  External-Interrupt Exiting: Can set=Yes, Can clear=Yes
        [  169.300728] 3  NMI Exiting: Can set=Yes, Can clear=Yes
        [  169.300729] 5  Virtual NMIs: Can set=Yes, Can clear=Yes
        [  169.300730] 6  Activate VMX-Preemption Timer: Can set=No, Can clear=Yes
        [  169.300731] 7  Process Posted Interrupts: Can set=No, Can clear=Yes
        [  169.300731] Printing Primary Processor-Based VM-Execution Controls...
        (continue to print...)

        If you see the info printed above, great, now we can actually start our A2/A3 (I dont know about you, but I'm half dead already...:CCC)


28. to make changes in the kvm hypervisor, we first need to navigate to 'arch' directory,
    then check both kvm.c and cpuid.c:
    
    cd ~/linux/arch/x86/kvm
    ls

    cpuid.c is what we are looking for here

    Note: this is not related to the A2/A3, but you will see directory 'vmx' and 'svm' here, 
    which corresponding to intel brand and amd brand cpu, and we can check vmx/vmx.c to see
    how intel handle the vm exit:
        vim cmx.c 
        /handle_exit
        /kvm_emulate_cpuid
            Note: you will notice that kvm_emulate_cpuid does not define here, then it must be defined somewhere else, lets find it!
        :qa
        cd ..
        grep -R kvm_emulate_cpuid *
            Note: you will see that both CPU brands pass the exit handle to cpuid.c for kvm_emulate_cpuid, so lets take a closer look.
        vim cpuid.c
            Note: there we go! function -> int kvm_emulate_cpuid(struct kvm_vcpu *cpu) is the main character that we are looking for in A2/A3,
                which handles all the kvm cpuid exit 

29. before we do anything to change the content of kvm.c and cpuid.c, let's save the original copy for future reference and comparison purpose:
        cp ~/linux/arch/x86/kvm/cpuid.c ~/CMPE283-VT/A2/source/cpuid.origin.c  
        diff ~/linux/arch/x86/kvm/cpuid.c ~/CMPE283-VT/A2/source/cpuid.origin.c  
        cp ~/linux/arch/x86/kvm/vmx/vmx.c ~/CMPE283-VT/A2/source/vmx.origin.c
        diff ~/linux/arch/x86/kvm/vmx/vmx.c ~/CMPE283-VT/A2/source/vmx.origin.c

30. now, following the requirements in the A2/A3 instructions, we will be modifying the CPUID emulation code in KVM to report back additional information
when special CPUID leaf nodes are requested:
    A2:
        %eax=0x4FFFFFFC -> Return the total number of exits (all types) in %eax
        
        %eax=0x4FFFFFFD -> Return the high 32 bits of the total time spent processing all exits in %ebx
                            Return the low 32 bits of the total time spent processing all exits in %ecx 
                            Note: %ebx and %ecx return values are measured in processor cycles, across all VCPUs
    A3:
        %eax=0x4FFFFFFE -> Return the number of exits for the exit number provided (on input) in %ecx
                            Note: This value should be returned in %eax
        
        %eax=0x4FFFFFFF -> Return the time spent processing the exit number provided (on input) in %ecx
                            Note: Return the high 32 bits of the total time spent for that exit in %ebx
                                    Return the low 32 bits of the total time spent for that exit in %ecx
        

        (CRITICAL)Note: For leaf nodes 0x4FFFFFFE and 0x4FFFFFFF, if %ecx (on input) contains a value not defined by the
                        SDM, return 0 in all %eax, %ebx, %ecx registers and return 0xFFFFFFFF in %edx. For exit types not
                        enabled in KVM, return 0s in all four registers.

                        In other words, when dealing A3:
                        -> if the value of %ecx is not in the valid range: %eax = %ebx = %ecx = 0, %edx = 0xFFFFFFFF
                        -> if the exit types not enabled in KVM -> %eax = %ebx = %ecx = %edx = 0


        Note: For the exit number provided in %ecx, we can check each of the supported number and its indicator in the textbook
                -> Combined Volume Set of Intel® 64 and IA-32 Architectures Software Developers Manuals
                -> Volume 3 (3A, 3B, 3C & 3D): System Programming Guide
                -> Appendix C VMX Basic Exit Reasons 
                -> Table C-1. Basic Exit Reasons (page 4285)

                Notice that some basic exit reason number does not exit, for example, 35, etc.
                In other words:
                -> The valid range for %ecx: 0~34, 36~37, 39~41, 43~69
                -> The invalid range for %ecx: 35, 38, 42, N>69


31. let's modify ~/linux/arch/x86/kvm/vmx/vmx.c first for A2 requirement:
    ...
    //extern global u32 variable (from cpuid.c) for recording total number of exits
    extern atomic_t total_exits_counter;
    //extern global uint64_t variable (from cpuid.c) for recording total number of cpu cycles on exits
    extern atomic64_t total_cup_cycles_counter;

    static int vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
    {
        // local uint64_t variables for record the beginning and the ending of processor's time stamp counter
        uint64_t begin_time_stamp_counter, end_time_stamp_counter;
        // local int variable to store the return status of vmx handler exit function
        int ret;

        // increase by 1 for every exit
        arch_atomic_inc(&total_exits_counter);
        // record the beginning of cpu's time stamp counter
        begin_time_stamp_counter = rdtsc();

        // call the corressponding exit handler to handle the exit
        ret = __vmx_handle_exit(vcpu, exit_fastpath);

        // record the ending of cpu's time stamp counter
        end_time_stamp_counter = rdtsc();
        // compute the current time stamp gap and add it to the total cpu cycle time
        arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &total_cup_cycles_counter);

        ...
    }
    ...


32. then modify ~/linux/arch/x86/kvm/cpuid.c for A2 requirement:
    ...
    //volatile int counter for total_exits_counter, atomically initialize to 0
    atomic_t total_exits_counter = ATOMIC_INIT(0);
    //export the variable total_exits_counter so vmx.c can use it
    EXPORT_SYMBOL(total_exits_counter);

    //volatile int64 counter for total_cup_cycles_counter, atomically initialize to 0
    atomic64_t total_cup_cycles_counter = ATOMIC64_INIT(0);
    //export the variable total_cup_cycles_counter so vmx.c can use it
    EXPORT_SYMBOL(total_cup_cycles_counter);

    int kvm_emulate_cpuid(struct kvm_vcpu *vcpu)
    {
        u32 eax, ebx, ecx, edx;

        if (cpuid_fault_enabled(vcpu) && !kvm_require_cpl(vcpu, 0))
            return 1;

        eax = kvm_rax_read(vcpu);
        ecx = kvm_rcx_read(vcpu);

        // check special new CPUID leaf that defined in A2
        switch(eax) {
            // case %eax = 0x4FFFFFFC
            case 0x4FFFFFFC:
                eax = arch_atomic_read(&total_exits_counter);
                //printk(KERN_INFO "### Total Exits in EAX = %u", eax);
                break;

            // case %eax = 0x4FFFFFFD
            case 0x4FFFFFFD:
                //the high 32 bits of the total time spent processing all exits store in %ebx
                ebx = (atomic64_read(&total_cup_cycles_counter) >> 32);;
                //the low 32 bits of the total time spent processing all exits store in %ecx
                ecx = (atomic64_read(&total_cup_cycles_counter) & 0xFFFFFFFF);

                //printk(KERN_INFO "### Total CPU Exit Cycle Time(hi) in EBX = %u", ebx);
                //printk(KERN_INFO "### Total CPU Exit Cycle Time(lo) in ECX = %u", ecx);
                break;

            // default case for all other %eax value
            default:
                kvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx, false);
            }

                kvm_rax_write(vcpu, eax);
                ...
        }
        ...

33. go back to the top level of ~/linux to build and install the modules again, then install the kernel:
        make -j <your-vm-cpu-total-core-number> modules
        sudo make -j <your-vm-cpu-total-core-number> INSTALL_MOD_STRIP=1 modules_install && make install
        sudo lsmod | grep kvm
        sudo rmmod kvm_intel
        sudo rmmod kvm
        sudo modprobe kvm
        sudo modprobe kvm_intel
        sudo lsmod | grep kvm

34. if there is no error, then we are ready to create a inner VM inside our current VM,
but first we need to install some extra tools for KVM, then check kvm-ok, and reboot:
        sudo apt-get install cpu-checker
        sudo apt update
        sudo apt-get install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils
        sudo kvm-ok
        sudo reboot


35. now we need to authorize a vm users for the inner VM, and verify our VM functionalities:
        uname -a
        sudo adduser '<your-name>' libvirt
                Note: you can check all your libvirt usser using the following command:
                        sudo getent group | grep libvirt
        sudo adduser '<your-name>' kvm
                Note: you can check all your kvm usser using the following command:
                sudo getent group | grep kvm
        sudo virsh list --all
                Note: it should show an empty list
        sudo systemctl status libvirtd
                Note: if everything is functioning properly, the output returns an active (running) status.
                        if it is not activate, do the following command to activate it
                        sudo systemctl enable --now libvirtd


36. now, we want to install some basic GUI functionalities on our VM for inner-vm interaction:
        Note: I tried so many ways to interact with the inner-VM using CLI only but failed,
                if you figured out how to host an inner-VM inside the current VM, do let me know! :d

        Note: Assuming you are following my step and hosted your VM on GCP, we can utilize the GUI functionalities
                supported by GCP (coooool)
        sudo apt update
        sudo apt install --assume-yes wget tasksel
        wget https://dl.google.com/linux/direct/chrome-remote-desktop_current_amd64.deb
        sudo apt-get install --assume-yes ./chrome-remote-desktop_current_amd64.deb
        sudo tasksel install ubuntu-desktop
        sudo bash -c ‘echo “exec /etc/X11/Xsession /usr/bin/gnome-session” > /etc/chrome-remote-desktop-session’
                Note: if it failed, its okay! :D
        sudo apt-get install xbase-clients
        sudo apt-get install python3-psutil
        sudo apt --fix-broken install
        sudo dpkg -i chrome-remote-desktop_current_amd64.deb
        mkdir ~/.config/chrome-remote-desktop
        exit

37. to fully enable the GUI functionalities provided by GCP, we need to first stop our VM and check the visual support box:
        Go to your GCP -> Compute Instance -> Stop the VM
        give it a few moment to stop...
        Then, go to your VM -> Edit -> Machine Configuration -> Enable Display Device -> Start the VM
        give it a few moment to start...

        then log back in to our VM:
                bash gcp-ssh-vm.sh -e <your-vm-external-IP>
        
38. cool! Now lets go to your localhost machine and open up your Chrome browser:
        Go to https://remotedesktop.google.com/headless
        (CRITICAL) Log in using the same account which you use for your GCP VM
        
        Note: For the following procedure, You only need to perform once
        
        Set up via SSH -> 
        Set uo another computer-> 
        begin -> next -> authorize ->
        copy the script with title 'Debian Linux' ->
        paste it into your VM terminal -> run ->

        Then you will get the following:
                Enter a PIN of at least six digits:
                Enter the same PIN again:
                [1204/020103.286183:INFO:daemon_controller_delegate_linux.cc(98)] Created symlink /etc/systemd/system/multi-user.target.wants/chrome-remote-desktop@junjie.service → /lib/systemd/system/chrome-remote-desktop@.service.

        You can test if the remote connection is set up by:
                sudo systemctl status chrome-remote-desktop@$USER

        Mark down the 6-digits pin you enter as we will bw using that connect to our VM

        Go back to your chrome browser -> remote access -> choose can click on your registered VM instance -> 
        type the 6-digits pin -> done! :D

                Note: the chrome-based GUI display of our VM terminal has configuration as well,
                        you can click on the eight edge of your window and pull it out. I recommended
                        setting your FPS from 30(default) to 60, so it looks less laggy when we interact
                        with our inner-VM later on

36. okay! we can now use virt-manager to create our inner VM along with the GUI:
        sudo apt install virt-manager
        cd ~
        wget https://releases.ubuntu.com/jammy/ubuntu-22.04.1-desktop-amd64.iso
        sudo mv ~/ubuntu-22.04.1-desktop-amd64.iso /var/lib/libvirt/images/
        sudo virt-manager
        
        If you get everything done correctly, the virt-manager GUI should pop up on your
        chrome browser already and ready for VM configuration:

        create a new virtual machine-> forward ->
        browse the OS image ISO -> 
        choose ubuntu-22.04.1-desktop-amd64.iso ->
        choose volume -> forward ->
        Memory -> half of your VM memory ->
        CPU -> all of your VM CPUs -> forward
        create a disk image for the virtual machine -> half of your VM memory -> forward
        name -> ubuntu-vm -> finish

        try or install ubuntu ->

        on and on and on....you should be quite familiar with ubuntu OS installation aren't you ;]

        After the ubuntu OS is installed, it will perform a reboot.

        Note: depends on your KVM's configurations, you may encounter situation where the inner-vm
                keeps frozen after the reboot -> it is common, and it is okay to force shut down and then
                start the VM again. 
        
37. now we can perform our A2 exit handling testing on the newly installed inner-VM:
        but first we need essential building tools:
        sudo apt-get update
        sudo apt-get install build-essential
        sudo apt-get install cpuid

        depends on your habit, you can either go ahead and write test.c or clone you existing A2 repo
        and write test.C

        A2_test.c:
                #include <stdio.h>
                #include <sys/types.h>


                static inline void
                __cpuid(unsigned int *eax, unsigned int *ebx, unsigned int *ecx,
                unsigned int *edx)
                {
                    asm volatile("cpuid"
                    : "=a" (*eax),"=b" (*ebx),"=c" (*ecx),"=d" (*edx)
                    : "0" (*eax), "1" (*ebx), "2" (*ecx), "3" (*edx));
                }

                int
                main(int argc, char **argv)
                {
                    unsigned int eax, ebx, ecx, edx;
                    unsigned long long cycle_time;

                    eax = 0x4FFFFFFC;
                    __cpuid(&eax, &ebx, &ecx, &edx);
                    printf("CPUID(0x4FFFFFFC), Total exit counter = %u \n", eax);

                    eax = 0x4FFFFFFD;
                    __cpuid(&eax, &ebx, &ecx, &edx);
                    cycle_time = (unsigned long long) ebx << 32 | ecx;
                    printf("CPUID(0x4FFFFFFD), Total exit cycles = %llu \n", cycle_time);
                }
        Makefile:
              default: build
              build:
              	g++ -o A2-test A2-test.c
              run:
              	./A2-test

38. compile and run A2-test.c to verify the result of CPUID leaf eax = 0x4FFFFFFC and eax = 0x4FFFFFFD:

    make
    make run

    A2-test result:
        (1st run)
        ./A2-test
        CPUID(0x4FFFFFFC), Total exit counter = 6460757
        CPUID(0x4FFFFFFD), Total exit cycles = 67151925918
        ---wait few seconds between runs---
        (2nd run)
        ./A2-test
        CPUID(0x4FFFFFFC), Total exit counter = 6466720
        CPUID(0x4FFFFFFD), Total exit cycles = 67174390690
        ---wait few seconds between runs---
        (3rd run)
        ./A2-test
        CPUID(0x4FFFFFFC), Total exit counter = 6471035
        CPUID(0x4FFFFFFD), Total exit cycles = 67191636674
        ---wait few seconds between runs---
        (4th run)
        ./A2-test
        CPUID(0x4FFFFFFC), Total exit counter = 6474505
        CPUID(0x4FFFFFFD), Total exit cycles = 67204865408
        ...
        (you can continue to run and test, but I think the result pattern is obvious enough...)
        (btw, you can go back to L1 VM and use command 'sudo dmesg' to verify the test result)

        We can see that based on the CPUID leaf node we implemented on 
        %eax = 0x4FFFFFFC and %eax = 0x4FFFFFFD, our total exit counter and 
        cpu cycles will be increasing continuously as basic exits (regardless of the type)
        constantly happens in our L2-VM (inner VM) and trigger the L1-VM
        (outer VM) to handle the exits and update the total exit counter
        and total exit cycles we implemented in cpuid.c and vmx.c

        Now we know that our VM triggers the exit handler function all the time,
        but we don't know the exact exit counter and exit cpu cycle time for
        different types of exits. It is very important to get to know these numbers
        as some type of exits happens a lot more frequently than others, and some type of 
        exits take a lot of cpu cycle time, while others only take a few. Lets move 
        forward to A3 where we will be implementing the other 2 CPUID leaf node 
        %eax = 0x4FFFFFFE and %eax = 0x4FFFFFFF to find out the secrets of those
        numbers! :D 

39. We need to revisit the requirements of A3 to see what we need to do to implement the leaf nodes required in A3:

        Lets first review the requirement of A3 again:
            A3:
                %eax=0x4FFFFFFE -> Return the number of exits for the exit number provided (on input) in %ecx
                                    Note: This value should be returned in %eax

                %eax=0x4FFFFFFF -> Return the time spent processing the exit number provided (on input) in %ecx
                                    Note: Return the high 32 bits of the total time spent for that exit in %ebx
                                            Return the low 32 bits of the total time spent for that exit in %ecx

                (CRITICAL)
                Note: For leaf nodes 0x4FFFFFFE and 0x4FFFFFFF, if %ecx (on input) contains a value not defined by the
                    SDM, return 0 in all %eax, %ebx, %ecx registers and return 0xFFFFFFFF in %edx. For exit types not
                    enabled in KVM, return 0s in all four registers.

                    In other words, when dealing A3:
                    -> if the value of %ecx is not in the valid range: %eax = %ebx = %ecx = 0, %edx = 0xFFFFFFFF
                    -> if the exit types not enabled in KVM -> %eax = %ebx = %ecx = %edx = 0

                Note: For the exit number provided in %ecx, we can check each of the supported number and its indicator in the textbook
                    -> Combined Volume Set of Intel® 64 and IA-32 Architectures Software Developers Manuals
                    -> Volume 3 (3A, 3B, 3C & 3D): System Programming Guide
                    -> Appendix C VMX Basic Exit Reasons
                    -> Table C-1. Basic Exit Reasons (page 4285)

                (CRITICAL)
                1st case: Notice that some basic exit reason number does not define in SDM, this is gonna be our first filter
                2nd case: Also, there are some basic exit reason number defined in SMD but not enabled in VMX, this is our second filter
                3rd case: Okay, whatever is left are the ones defined in SMD and enabled in VMX, great
                4th case: Oh, you say there are cases not defined in SDM but enabled in VMX? You are absolutely right!
                            but guess what, since they are not even defined in SDM in the first place, we dont careeeee :DDD

                To check these cases, you need to refer to the following:
                    SDM defined basic exit reason numbers:
                        -> Combined Volume Set of Intel® 64 and IA-32 Architectures Software Developers Manuals, Table C-1. Basic Exit Reasons (page 4285)
                    VMX enabled basic exit reason numbers:
                        -> vmx.h -> linux/arch/x86/include/uapi/asm/vmx.h
                                 -> or the vmx.origin.h in my A3/source directory if you are a lazy ass :DDD (Joking! don't do it loool its not recommended)

                (Not important)
                A decade has been passed....just for checking these numbers!!!
                BRUHHHH, why cant they just say it or comment it when they implement it!! :CCC

                Okay lets summarizes it a little:
                    The 1st invalid range for %ecx(not defined in SDM):
                        -> N<0, N>69, 35, 38, 42
                    The 2nd invalid range for %ecx(not enabled in KVM):
                        -> 5, 6, 11, 17, 65, 66, 69
                    The valid range for %ecx(defined in SDM and enabled in KVM):
                        -> 0~4, 7~10, 12~16, 18~34, 36~37, 39~41, 43~64, 67~68

                (CRITICAL)
                The above info are retried from textbook Combined Volume Set of Intel® 64 and IA-32 Architectures Software Developers Manuals
                with version 09/30/2022 and vmx.h with last commit in 06/08/2022. Therefore, when referencing my work, make sure to double-check
                the range of Basic Exit Reasons in the most up-to-date version of the textbook and in vmx.h as things might change! :d


40. We can also revisit the implementation of A2 to see what we can re-use to implement the leaf nodes required in A3:
        We can recall what we did to fulfill the requirement of A2:

        In linux/arch/x86/kvm/vmx/vmx.c, vmx_handle_exit(), we did:
                arch_atomic_inc(&total_exits_counter);
                    -> to update the total exit counter
                arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &total_cpu_cycles_counter);
                    -> to update the total cpu exit cycle

        Maybe we can do something similar to A2 to get A3 done...? Let's see: since A3 start to require us to update
        one specific type of exit counter and exit time cycle, we can do something like:
            extern atomic_t type_exits_counter[70];
            extern atomic64_t type_cpu_cycles_counter[70];

            arch_atomic_inc(&type_exits_counter[???]);
                -> to update the type-specific exit counter
            arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &type_cpu_cycles_counter[???]);
                -> to update the type-specific cpu exit cycle

        Cool, we are close, we now only need to figure out the correct index to fill in the ??? hole.

        But what should they be...? A3 already told us to read the value of %ecx to judge the exit type, but where can we
        read the value of %ecx?

        Well, to obtain the info of %ecx, we need to first access the info that stores in exit_reason.basic,
        and it can be derived from struct vmx:
            struct vcpu_vmx *vmx = to_vmx(vcpu);
            union vmx_exit_reason exit_reason = vmx->exit_reason;

        Do we have it ready in A2 so that we can simply use it...? Welp, No.

        Okay, what we did in A2 is actually quick and dirty: we did not care about the type of exits,
        and we just add 1 to the total exit counter and add exit time duration to the total exit
        cpu cycle time. We did not touch __vmx_handle_exit() as things can be done in vmx_handle_exit().

        However, we need to get the info in %ecx if we want to record exit count and cpu cycle time for one specific
        exit type, and the implementation we have in A2 cannot help us as we did not check the value of %ecx.
        In fact, since we only touched vmx_handle_exit() and did not touch __vmx_handle_exit(), we dont have the
        info of %ecx at all! :d

        Luckily, if we look at the implementation of __vmx_handle_exit(), we can notice that it has the pointer variable
        with struct vcpu_vmx which has all the info of vcpu for vmx usage:

        linux/arch/x86/kvm/vmx/vmx.c, __vmx_handle_exit():
        	struct vcpu_vmx *vmx = to_vmx(vcpu);
        	union vmx_exit_reason exit_reason = vmx->exit_reason;
        It is right there at the beginning of __vmx_handle_exit()! Now we can freely access the basic exit info in %ecx,
        which stores in exit_reason.basic.

        So our A3 type specified exit counter and cycle update will look the following:

        linux/arch/x86/kvm/vmx/vmx.c, __vmx_handle_exit():
            arch_atomic_inc(&type_exits_counter[exit_reason.basic]);
                -> to update the type-specific exit counter
            arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &type_cpu_cycles_counter[exit_reason.basic]);
                -> to update the type-specific cpu exit cycle

        Great, now we just need to refactor what we did in vmx.c -> vmx_handle_exit() and put it in __vmx_handle_exit() for A2
        (pay the technical debt we had in A2), and implement the new features for A3 in vmx.c -> __vmx_handle_exit() and
        cpuid.c -> kvm_emulate_cpuid()

        Also, to make our code more readable, we should implement our %ecx value validation check (discussed in step 39)
        in a more readable and maintainable way inside the cpuid.c:
            // helper condition checking function for ecx value validation in SDM
            bool ecx_defined_in_sdm(u32 *ecx) {
                return (*ecx >=0 && *ecx <= 69 && *ecx != 35 && *ecx != 38 && *ecx != 42);
            }
            // helper condition checking function for ecx value validation in VMX
            bool ecx_enabled_in_vmx(u32 *ecx) {
                return (*ecx != 5 && *ecx != 6 && *ecx != 11 && *ecx != 17 && *ecx != 65 && *ecx != 66 && *ecx != 69);
            }

        Okay! so our total work field is the following:
            linux/arch/x86/kvm/vmx/vmx.c:
                vmx_handle_exit(), __vmx_handle_exit()
            linux/arch/x86/kvm/cpuid.c:
                kvm_emulate_cpuid()
            linux/arch/x86/kvm/cpuid.h:
                declaration of helper functions:
                    -> bool ecx_defined_in_sdm(u32 *ecx);
                    -> bool ecx_enabled_in_vmx(u32 *ecx);


41. let's modify ~/linux/arch/x86/kvm/vmx/vmx.c first for A3 requirement:
    vmx.c:
        //extern global volatile int32 variable total_exits_counter (from cpuid.c)
        //for recording total number of exits (all types)
        extern atomic_t total_exits_counter;
        //extern global volatile int64 variable total_cpu_cycles_counter (from cpuid.c)
        //for recording total number of cpu cycles on exits (all types)
        extern atomic64_t total_cpu_cycles_counter;

        //extern global volatile int32 array variable type_exits_counter (from cpuid.c)
        //for recording total number of exits (type-specified)
        extern atomic_t type_exits_counter[70];
        //extern global volatile int64 array variable type_cpu_cycles_counter (from cpuid.c)
        //for recording total number of cpu cycles on exits (type-specified)
        extern atomic64_t type_cpu_cycles_counter[70];

        static int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
        {
            struct vcpu_vmx *vmx = to_vmx(vcpu);
            union vmx_exit_reason exit_reason = vmx->exit_reason;
            u32 vectoring_info = vmx->idt_vectoring_info;
            u16 exit_handler_index;

            // local uint64_t variables for record the beginning and the ending of processor's time stamp counter
            uint64_t begin_time_stamp_counter, end_time_stamp_counter;
            // local int variable to store the return status of vmx handler exit function
            int exit_handler_status;
            ...
            ...
            exit_handler_index = array_index_nospec((u16)exit_reason.basic,
                                kvm_vmx_max_exit_handlers);
            if (!kvm_vmx_exit_handlers[exit_handler_index])
                goto unexpected_vmexit;

            // increase by 1 for every exit
            arch_atomic_inc(&total_exits_counter);

            // increase by 1 for current type-specified exit
            if (exit_reason.basic < 70) {
                arch_atomic_inc(&type_exits_counter[(int)exit_reason.basic]);
            }
            // record the beginning of cpu's time stamp counter
            begin_time_stamp_counter = rdtsc();

            // call the corresponding exit handler to handle the exit
            exit_handler_status = kvm_vmx_exit_handlers[exit_handler_index](vcpu);

            // record the ending of cpu's time stamp counter
            end_time_stamp_counter = rdtsc();

            // compute the current time stamp gap and add it to the cpu cycle time of total exits
            arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &total_cpu_cycles_counter);

            // compute the current time stamp gap and add it to the cpu cycle time of type-specified exit
            if (exit_reason.basic < 70) {
                arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &type_cpu_cycles_counter[(int)exit_reason.basic]);
            }

            return exit_handler_status;
            ...
            ...
        }

42. then modify ~/linux/arch/x86/kvm/cpuid.c for A3 requirement:

    cpuid.c:
        //volatile int32 counter for recording total number of exits (all types), atomically initialize to 0
        atomic_t total_exits_counter = ATOMIC_INIT(0);
        //export the variable total_exits_counter so vmx.c can use it
        EXPORT_SYMBOL(total_exits_counter);

        //volatile int64 counter for recording total number of cpu cycles on exits (all types), atomically initialize to 0
        atomic64_t total_cpu_cycles_counter = ATOMIC64_INIT(0);
        //export the variable total_cup_cycles_counter so vmx.c can use it
        EXPORT_SYMBOL(total_cpu_cycles_counter);

        //volatile int64 counter for recording total number of exits (type-specified), all initialize to 0 internally
        atomic_t type_exits_counter[70];
        //export the variable type_exits_counter so vmx.c can use it
        EXPORT_SYMBOL(type_exits_counter);

        //volatile int64 counter for recording total number of cpu cycles on exits (type-specified), atomically initialize to 0
        atomic64_t type_cpu_cycles_counter[70];
        //export the variable type_cpu_cycles_counter so vmx.c can use it
        EXPORT_SYMBOL(type_cpu_cycles_counter);

        int kvm_emulate_cpuid(struct kvm_vcpu *vcpu)
        {
            u32 eax, ebx, ecx, edx;
            // u32 variable for copying the value of ECX in case %eax = 0x4FFFFFFE and %eax = 0x4FFFFFFF
            u32 ecx_copy;
            // u64 variable for copying the value of exit counter from atomic64_read() in case %eax = 0x4FFFFFFD and %eax = 0x4FFFFFFF
            u64 cycle_counter;

            if (cpuid_fault_enabled(vcpu) && !kvm_require_cpl(vcpu, 0))
                return 1;

            eax = kvm_rax_read(vcpu);
            ecx = kvm_rcx_read(vcpu);

            // check special new CPUID leaf that defined in A2
            switch(eax) {
                // case %eax = 0x4FFFFFFC
                case 0x4FFFFFFC:
                    printk(KERN_INFO "### CPUID(0x4FFFFFFC) -> ");
                    eax = arch_atomic_read(&total_exits_counter);
                    printk(KERN_INFO "### Total Exits = %u", eax);
                    //printk(KERN_INFO "### Total Exits in EAX = %u", eax);
                    break;

                // case %eax = 0x4FFFFFFD
                case 0x4FFFFFFD:
                    printk(KERN_INFO "### CPUID(0x4FFFFFFD) -> ");
                    cycle_counter = atomic64_read(&total_cpu_cycles_counter);
                    //the high 32 bits of the total time spent processing all exits store in %ebx
                    ebx = (cycle_counter >> 32);;
                    //the low 32 bits of the total time spent processing all exits store in %ecx
                    ecx = (cycle_counter & 0xFFFFFFFF);
                    printk(KERN_INFO "### Total CPU Exit Cycle Time = %llu", cycle_counter);
                    //printk(KERN_INFO "### Total CPU Exit Cycle Time(hi) in EBX = %u", ebx);
                    //printk(KERN_INFO "### Total CPU Exit Cycle Time(lo) in ECX = %u", ecx);
                    break;

                // case %eax = 0x4FFFFFFE
                case 0x4FFFFFFE:
                    printk(KERN_INFO "### CPUID(0x4FFFFFFE) -> ECX = %u", ecx);
                    // check if the value of %ecx is defined in SDM
                    if (ecx_defined_in_sdm(&ecx)) {
                        // check if the value of %ecx is enable in VMX
                        if (ecx_enabled_in_vmx(&ecx)) {
                            ecx_copy = ecx;
                            eax = arch_atomic_read(&type_exits_counter[(int)ecx]);
                            printk(KERN_INFO "### Type %u Exit Count = %u", ecx_copy, eax);
                            //printk(KERN_INFO "### Type %u Total Exits in EAX = %u", ecx_copy, eax);
                        } else {
                            printk(KERN_INFO "### Exit Number in ECX Defined in SDM But Not Enabled in KVM ");
                            eax = 0; ebx = 0; ecx = 0; edx = 0;
                        }
                    } else {
                        printk(KERN_INFO "### Exit Number in ECX Not Defined in SDM ");
                        eax = 0; ebx = 0; ecx = 0; edx = 0xFFFFFFFF;
                    }
                    break;

                // case %eax = 0x4FFFFFFF
                case 0x4FFFFFFF:
                    printk(KERN_INFO "### CPUID(0x4FFFFFFF) -> ECX = %u", ecx);
                    // check if the value of %ecx is defined in SDM
                    if (ecx_defined_in_sdm(&ecx)) {
                        // check if the value of %ecx is enable in VMX
                        if (ecx_enabled_in_vmx(&ecx)) {
                            ecx_copy = ecx;
                            cycle_counter = atomic64_read(&type_cpu_cycles_counter[(int)ecx]);
                            //the high 32 bits of the total time spent processing all exits store in %ebx
                            ebx = (cycle_counter >> 32);;
                            //the low 32 bits of the total time spent processing all exits store in %ecx
                            ecx = (cycle_counter & 0xFFFFFFFF);
                            printk(KERN_INFO "### Type %u CPU Exit Cycle Time = %llu", ecx_copy, cycle_counter);
                            //printk(KERN_INFO "### Type %u CPU Exit Cycle Time(hi) in EBX = %u", ecx_copy, ebx);
                            //printk(KERN_INFO "### Type %u CPU Exit Cycle Time(lo) in ECX = %u", ecx_copy, ecx);
                        } else {
                            printk(KERN_INFO "### Exit Number in ECX Defined in SDM But Not Enabled in KVM ");
                            eax = 0; ebx = 0; ecx = 0; edx = 0;
                        }
                    } else {
                            printk(KERN_INFO "### Exit Number in ECX Not Defined in SDM ");
                            eax = 0; ebx = 0; ecx = 0; edx = 0xFFFFFFFF;
                    }
                    break;

                // default case for all other %eax value
                default:
                    kvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx, false);
            }

            kvm_rax_write(vcpu, eax);
            kvm_rbx_write(vcpu, ebx);
            kvm_rcx_write(vcpu, ecx);
            kvm_rdx_write(vcpu, edx);
            return kvm_skip_emulated_instruction(vcpu);
        }

        // helper condition checking function for ecx value validation in SDM
        bool ecx_defined_in_sdm(u32 *ecx) {
            return (*ecx >= 0 && *ecx <= 69 && *ecx != 35 && *ecx != 38 && *ecx != 42);
        }
        // helper condition checking function for ecx value validation in VMX
        bool ecx_enabled_in_vmx(u32 *ecx) {
            return (*ecx != 5 && *ecx != 6 && *ecx != 11 && *ecx != 17 && *ecx != 65 && *ecx != 66 && *ecx != 69);
        }

43. finally, modify ~/linux/arch/x86/kvm/cpuid.h to add declaration for the helper functions we defined in cpuid.c:

    cpuid.h:
        ...
        extern u32 kvm_cpu_caps[NR_KVM_CPU_CAPS] __read_mostly;

        // Assignment 3 Modification ->
        // declaration for helper functions defined in cpuid.c
        bool ecx_defined_in_sdm(u32 *ecx);
        bool ecx_enabled_in_vmx(u32 *ecx);

        void kvm_set_cpu_caps(void);
        ...

44. go back to the top level of ~/linux to build and install the modules again, then install the kernel:
        make -j <your-vm-cpu-total-core-number> modules
        sudo make -j <your-vm-cpu-total-core-number> INSTALL_MOD_STRIP=1 modules_install && make
        sudo lsmod | grep kvm
        sudo rmmod kvm_intel
        sudo rmmod kvm
        sudo modprobe kvm
        sudo modprobe kvm_intel
        sudo lsmod | grep kvm
        sudo kvm-ok
        sudo reboot

45. now we can perform our A3 exit handling testing on the inner-VM:

    A3-test.c:
        printf("\n-----Test Leaf Node CPUID(0x4FFFFFFC)-----\n\n");
        eax = 0x4FFFFFFC;
        __cpuid(&eax, &ebx, &ecx, &edx);
        printf("CPUID(0x4FFFFFFC), All Type Total Exit Counter = %u \n", eax);
        printf("EAX = %u  EBX = %u ECX = %u EDX = %u \n", eax, ebx, ecx, edx);


        printf("\n-----Test Leaf Node CPUID(0x4FFFFFFD)-----\n\n");
        eax = 0x4FFFFFFD;
        __cpuid(&eax, &ebx, &ecx, &edx);
        cycle_time = (unsigned long long) ebx << 32 | ecx;
        printf("CPUID(0x4FFFFFFD), All Type Total Exit Cycles = %llu \n", cycle_time);
        printf("EAX = %u  EBX = %u ECX = %u EDX = %u \n", eax, ebx, ecx, edx);

        /*
        For CPUID(0x4FFFFFFE) and CPUID(0x4FFFFFFF)
        test range [0, 74] to include 3 cases:
            The 1st invalid range for %ecx(not defined in SDM):
                -> N<0, N>69, 35, 38, 42
            The 2nd invalid range for %ecx(not enabled in KVM):
                -> 5, 6, 11, 17, 65, 66, 69
            The valid range for %ecx(defined in SDM and enabled in KVM):
                -> 0~4, 7~10, 12~16, 18~34, 36~37, 39~41, 43~64, 67~68
            Note: above indexs referenced from textbook Combined Volume Set of Intel® 64 and IA-32 Architectures Software Developers Manuals
            with version 09/30/2022 and vmx.h with last commit in 06/08/2022.
        */

        printf("\n-----Test Leaf Node CPUID(0x4FFFFFFE)-----\n\n");
        for(i = 0; i < 75; i++) {
            eax = 0x4FFFFFFE;
            ecx = i;
            ecx_copy = ecx;
            __cpuid(&eax, &ebx, &ecx, &edx);
            printf("CPUID(0x4FFFFFFE), Type %u Total Exit Counter = %u \n", ecx_copy, eax);
            printf("EAX = %u  EBX = %u ECX = %u EDX = %u \n", eax, ebx, ecx, edx);
        }

        printf("\n-----Test Leaf Node CPUID(0x4FFFFFFF)-----\n\n");
        for(i = 0; i < 75; i++) {
            eax = 0x4FFFFFFF;
            ecx = i;
            ecx_copy = ecx;
            __cpuid(&eax, &ebx, &ecx, &edx);
                cycle_time = (unsigned long long) ebx << 32 | ecx;
            printf("CPUID(0x4FFFFFFF), Type %u Total Exit Cycles = %llu \n", ecx_copy, cycle_time);
            printf("EAX = %u  EBX = %u ECX = %u EDX = %u \n", eax, ebx, ecx, edx);
        }


    In L2 VM:
        make
        make run

    A3-test result:
        see A3/screenshots/VM-L2-A3-test-result-E-0~4.jpg
            A3/screenshots/VM-L2-A3-test-result-F-0~4.jpg
            A3/screenshots/VM-L2-A3-test-result-statics-0~2.jpg


46. we can verify our A3-test result on our outer L1 VM as well using command dmesg:

    In L1 VM:
        sudo dmesg

    dmesg result:
        see A3/screenshots/VM-L1-demsg-for-A3-test-E-0~3.jpg
            A3/screenshots/VM-L1-demsg-for-A3-test-F-0~3.jpg


47. lets analyze the A3 result and see what is going on here:

    (refer to linux/arch/x86/include/uapi/asm/vmx.h and Table C-1. Basic Exit Reasons (page 4285))
        see A3/screenshots/SDM-defined-exit-reasons[0-22][version-2022-09-30].jpg
            A3/screenshots/SDM-defined-exit-reasons[23-45][version-2022-09-30].jpg
            A3/screenshots/SDM-defined-exit-reasons[46-69][version-2022-09-30].jpg
        and KVM-enabled-exit-reasons[0-75][version-2022-06-08].jpg

    Lets list it out the basic reason exit :

    // NULL                             N < 0 -> not defined in SDM (impossible since %ecx value type is is unsigned int 32)
    #define EXIT_REASON_EXCEPTION_NMI       0
    #define EXIT_REASON_EXTERNAL_INTERRUPT  1
    #define EXIT_REASON_TRIPLE_FAULT        2
    #define EXIT_REASON_INIT_SIGNAL			3
    #define EXIT_REASON_SIPI_SIGNAL         4
    // I/O system-management interrupt      5 -> not enabled in KVM
    // Other SMI                            6 -> not enabled in KVM
    #define EXIT_REASON_INTERRUPT_WINDOW    7
    #define EXIT_REASON_NMI_WINDOW          8
    #define EXIT_REASON_TASK_SWITCH         9
    #define EXIT_REASON_CPUID               10
    // GETSEC                               11 -> not enabled in KVM
    #define EXIT_REASON_HLT                 12
    #define EXIT_REASON_INVD                13
    #define EXIT_REASON_INVLPG              14
    #define EXIT_REASON_RDPMC               15
    #define EXIT_REASON_RDTSC               16
    // RSM                                  17 -> not enabled in KVM
    #define EXIT_REASON_VMCALL              18
    #define EXIT_REASON_VMCLEAR             19
    #define EXIT_REASON_VMLAUNCH            20
    #define EXIT_REASON_VMPTRLD             21
    #define EXIT_REASON_VMPTRST             22
    #define EXIT_REASON_VMREAD              23
    #define EXIT_REASON_VMRESUME            24
    #define EXIT_REASON_VMWRITE             25
    #define EXIT_REASON_VMOFF               26
    #define EXIT_REASON_VMON                27
    #define EXIT_REASON_CR_ACCESS           28
    #define EXIT_REASON_DR_ACCESS           29
    #define EXIT_REASON_IO_INSTRUCTION      30
    #define EXIT_REASON_MSR_READ            31
    #define EXIT_REASON_MSR_WRITE           32
    #define EXIT_REASON_INVALID_STATE       33
    #define EXIT_REASON_MSR_LOAD_FAIL       34
    // NULL                                 35 -> not defined in SDM
    #define EXIT_REASON_MWAIT_INSTRUCTION   36
    #define EXIT_REASON_MONITOR_TRAP_FLAG   37
    // NULL                                 38 -> not defined in SDM
    #define EXIT_REASON_MONITOR_INSTRUCTION 39
    #define EXIT_REASON_PAUSE_INSTRUCTION   40
    #define EXIT_REASON_MCE_DURING_VMENTRY  41
    // NULL                                 42 -> not defined in SDM
    #define EXIT_REASON_TPR_BELOW_THRESHOLD 43
    #define EXIT_REASON_APIC_ACCESS         44
    #define EXIT_REASON_EOI_INDUCED         45
    #define EXIT_REASON_GDTR_IDTR           46
    #define EXIT_REASON_LDTR_TR             47
    #define EXIT_REASON_EPT_VIOLATION       48
    #define EXIT_REASON_EPT_MISCONFIG       49
    #define EXIT_REASON_INVEPT              50
    #define EXIT_REASON_RDTSCP              51
    #define EXIT_REASON_PREEMPTION_TIMER    52
    #define EXIT_REASON_INVVPID             53
    #define EXIT_REASON_WBINVD              54
    #define EXIT_REASON_XSETBV              55
    #define EXIT_REASON_APIC_WRITE          56
    #define EXIT_REASON_RDRAND              57
    #define EXIT_REASON_INVPCID             58
    #define EXIT_REASON_VMFUNC              59
    #define EXIT_REASON_ENCLS               60
    #define EXIT_REASON_RDSEED              61
    #define EXIT_REASON_PML_FULL            62
    #define EXIT_REASON_XSAVES              63
    #define EXIT_REASON_XRSTORS             64
    // PCONFIG                              65 -> not enabled in KVM
    // SPP-related event                    66 -> not enabled in KVM
    #define EXIT_REASON_UMWAIT              67
    #define EXIT_REASON_TPAUSE              68
    // LOADIWKEY                            69 -> not enabled in KVM
    // NULL                             N > 69 -> not defined in SDM
    #define EXIT_REASON_BUS_LOCK            74 -> not defined in SDM
    #define EXIT_REASON_NOTIFY              75 -> not defined in SDM

    Since our A3 test cases ecx value range is [0, 74], it covered all 3 cases:
        The 1st invalid range for %ecx(not defined in SDM):
            -> N<0, N>69, 35, 38, 42
        The 2nd invalid range for %ecx(not enabled in KVM):
            -> 5, 6, 11, 17, 65, 66, 69
        The valid range for %ecx(defined in SDM and enabled in KVM):
            -> 0~4, 7~10, 12~16, 18~34, 36~37, 39~41, 43~64, 67~68

    Lets analyze the result from A3 test and focusing on the ones that is:
        1.invalid
            -> to check our A3 implementations on handling error
        2.valid AND has positive exit counter and cycles
            -> to see which type of the exit has the highest/lowest initial/increment value in exit counter/cycles/performance ratio(cycles/exit)

    From L2 A3-test result and L1 dmesg info we can confirm that all invalid cases are handled correctly! :D

    From L2 A3-test result section 'Statics Overview For Each Basic Exit' we can see that:
    only exit type 0, 10, 18, 28, 29, 30, 31, 46, 47, 48, 54, 55 are triggered during the L2 nested virtualization
    the rest did not get triggered and thus no info available for us to analyze

    Also, a full VM boot entails:
    1st run of A3-test after boost -> total 912772 exits with total 13080154698 cycle times

    The complete result list of the 1st A3-test run goes as follows:
        exit number      exit reason                    exit counter        exit cycles             cycles/exit
        0                EXIT_REASON_EXCEPTION_NMI      20269               3217133614              158721
        10               EXIT_REASON_CPUID              211975              246604414               1163
        18               EXIT_REASON_VMCALL             796                 224014430               281425
        28               EXIT_REASON_CR_ACCESS          33511               50333102                1501
        29               EXIT_REASON_DR_ACCESS          4                   34058                   8514
        30               EXIT_REASON_IO_INSTRUCTION     153922              235386992               1529
        31               EXIT_REASON_MSR_READ           995                 1894430                 1903
        46               EXIT_REASON_GDTR_IDTR          13                  357048                  27465
        47               EXIT_REASON_LDTR_TR            6                   199892                  33315
        48               EXIT_REASON_EPT_VIOLATION      491283              9104728822              18532
        54               EXIT_REASON_WBINVD             5                   3962                    792
        55               EXIT_REASON_XSETBV             5                   127442                  25488

    we can see that:
        -> exit type 48 EXIT_REASON_EPT_VIOLATION has the highest type-specified total exit counter
            -> it happens the most frequent
        -> exit type 29 EXIT_REASON_DR_ACCESS has the lowest type-specified total exit counter
            -> it happens the least frequent (among the ones that actually happens)
        -> exit type 48 EXIT_REASON_EPT_VIOLATION has the highest type-specified total exit cycles
            -> it takes the most total cpu cycle time
        -> exit type 54 EXIT_REASON_WBINVD has the lowest type-specified total exit cycles
            -> it takes the least total cpu cycle time (among the ones that actually happens)
        -> exit type 18 EXIT_REASON_VMCALL has the highest cycles/exit ratio
            -> it is most time consuming when handling
        -> exit type 54 EXIT_REASON_WBINVD has the lowest cycles/exit ratio
            -> it is least time consuming when handling

   now we need to run A3-test again and see how these exit statics changes over time:

   2nd run of A3-test after boost -> total 935273 exits with total 13267981350 cycle times

   The complete result list of the 1st A3-test run goes as follows:
        exit number      exit reason                    exit counter        exit cycles             cycles/exit
        0                EXIT_REASON_EXCEPTION_NMI      20269               3217133614              158721
        10               EXIT_REASON_CPUID              216494(+4519)       252757104(+6122690)     1167(+4)
        18               EXIT_REASON_VMCALL             1131(+335)          307660396(+83645966)    272025(-9400)
        28               EXIT_REASON_CR_ACCESS          33511               50333102                1501
        29               EXIT_REASON_DR_ACCESS          4                   34058                   8514
        30               EXIT_REASON_IO_INSTRUCTION     157291(+3369)       248583150(+13196158)    1529(+51)
        31               EXIT_REASON_MSR_READ           15249(+14254)       39791236(+37896806)     2069(+166)
        46               EXIT_REASON_GDTR_IDTR          13                  357048                  27465
        47               EXIT_REASON_LDTR_TR            6                   199892                  33315
        48               EXIT_REASON_EPT_VIOLATION      491307(+24)         9151600740(+46871918)   18627(+95)
        54               EXIT_REASON_WBINVD             5                   3962                    792
        55               EXIT_REASON_XSETBV             5                   127442                  25488

    we can see that:
        -> exit type 0, 28, 29, 46, 47, 54, 55 stays and does not have any increment
            -> they seems to be the ones that rarely trigger after the VM is fully boosted
        -> exit type 31 EXIT_REASON_MSR_READ has the highest increment on type-specified total exit counter
            -> over time it will happens more and more frequent
        -> exit type 48 EXIT_REASON_EPT_VIOLATION has the lowest increment on type-specified total exit counter
            -> over time it will happens less and less frequent (among the ones that actually has increment)
        -> exit type 18 EXIT_REASON_VMCALL has the highest increment in type-specified total exit cycles
            -> it increase the most mainly due to high cycles/exit ratio, so it is more sensitive to exit increments.
        -> exit type 10 EXIT_REASON_CPUID has the lowest increment in type-specified total exit cycles
            -> it increase the least mainly due to low cycles/exit ratio, so it is less sensitive to exit increments.
        -> exit type 18 EXIT_REASON_VMCALL has the highest delta in cycles/exit ratio
            -> again, due to high cycles/exit ratio, the re-computed value more likely to be changed when exit counter changes
        -> exit type 10 EXIT_REASON_CPUID has the lowest delta in cycles/exit ratio
            -> again, due to low cycles/exit ratio, the re-computed value more likely to stay the same even exit counter changes

   now we have concrete answers to the A3 instructions:

        1. Does the number of exits increase at a stable rate?
            -> No, some of the exits increase, some of them stay the same. Among the ones that increase,
                they have different increment ratio depends on the exit type.
        2. Are there more exits performed during certain VM operations?
            -> Yes, for example, EXIT_REASON_CPUID(10), EXIT_REASON_IO_INSTRUCTION(30), EXIT_REASON_MSR_READ(31), etc.
        3. Approximately how many exits does a full VM boot entail?
            -> It entails total 912772 exits with total 13080154698 cycle times.
        4. Of the exit types defined in the SDM, which are the most frequent? Least?
            -> EXIT_REASON_EPT_VIOLATION(48) happens the most frequent, EXIT_REASON_DR_ACCESS(29) happens the least frequent;
            EXIT_REASON_MSR_READ(31) has the highest increment over time, EXIT_REASON_EPT_VIOLATION(48) has the lowest increment over time,


Conclusion:
   Thanks to A3, we now have a very clear picture of all the SDM-defined and KVM-enabled basic exit types and their
   corresponding initial/increment value in exit counter/cycles/performance ratio(cycles/exit), so we know which one
   to pay close attention to when modifying/optimizing our hypervisor so that our VMs that run on top of it can have
   the least performance(cpu cycle time) overhead.

   Many thanks to Prof. Mike Larkin and GCP Education Team so that I can study Virtualization Technologies and gain
   hands-on experiences in Nested Virtualization, Kernel Modification, and adding new CPUID leaf nodes to the KVM
   hypervisor to empower it with new features.

   Okay, that's about it, see you around, my friend. ;]


Postscript:
   I hope my guides and the assignment log-books actually helped you to study these Virtualization Technologies topics :D,
   and I encourage you to do the same(if you feel like it), so the students that came after us can learn them without misery
   (feeling lost, don't know what to do, stuck all day, etc.), which most of the time is unnecessary. I care because
   I am once in their shoes, so I know how painful and helpless it could be, epically I know I keep failing not because
   I am dumb but only because of lacking domain-specific knowledge and experience. you should know that it also applies
   to you and everyone else. Just how great it could be if someone could be there for us and help us go through these subjects,
   right? ;D

   Luckily, some people(or I should call them heroes!) during my hardest time, like Qingwei Zen, Jack Gong, and many others.
   The kindness and courage they pass down on me enable me to be there for you, and it would be great if you could be there
   for others in the future.

   May the force and courage be with you.




