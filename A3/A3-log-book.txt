---CRITICAL NOTE---
All commands listed here are done in a Linux(Ubuntu) machine, so try to modify some steps/elements if you are using Windows/Mac.

For A3, we will be re-using the environment we created in A2 (modified L1-VM kernel, created L2-VM with nested virtualization).
Therefore, before you perform any steps below, you should make sure you have already correctly set up the environment following
A2-log-book.txt steps 0~38. If not, do not perform any of the following steps, got to A2-log-book.txt and follows steps 0~38 to
set up the needed environment first. :d

However, if you have the environment ready to go, then just go ahead and follow the A3-log-book to study A3 with me! :D


0. First, we need to revisit the requirements of A3 to see what we need to do to implement the leaf nodes required in A3:

    Lets first review the requirement of A3 again:
        A3:
            %eax=0x4FFFFFFE -> Return the number of exits for the exit number provided (on input) in %ecx
                                Note: This value should be returned in %eax

            %eax=0x4FFFFFFF -> Return the time spent processing the exit number provided (on input) in %ecx
                                Note: Return the high 32 bits of the total time spent for that exit in %ebx
                                        Return the low 32 bits of the total time spent for that exit in %ecx

            (CRITICAL)
            Note: For leaf nodes 0x4FFFFFFE and 0x4FFFFFFF, if %ecx (on input) contains a value not defined by the
                SDM, return 0 in all %eax, %ebx, %ecx registers and return 0xFFFFFFFF in %edx. For exit types not
                enabled in KVM, return 0s in all four registers.

                In other words, when dealing A3:
                -> if the value of %ecx is not in the valid range: %eax = %ebx = %ecx = 0, %edx = 0xFFFFFFFF
                -> if the exit types not enabled in KVM -> %eax = %ebx = %ecx = %edx = 0

            Note: For the exit number provided in %ecx, we can check each of the supported number and its indicator in the textbook
                -> Combined Volume Set of Intel速 64 and IA-32 Architectures Software Developers Manuals
                -> Volume 3 (3A, 3B, 3C & 3D): System Programming Guide
                -> Appendix C VMX Basic Exit Reasons
                -> Table C-1. Basic Exit Reasons (page 4285)

            (CRITICAL)
            1st case: Notice that some basic exit reason number does not define in SDM, this is gonna be our first filter
            2nd case: Also, there are some basic exit reason number defined in SMD but not enabled in VMX, this is our second filter
            3rd case: Okay, whatever is left are the ones defined in SMD and enabled in VMX, great
            4th case: Oh, you say there are cases not defined in SDM but enabled in VMX? You are absolutely right!
                        but guess what, since they are not even defined in SDM in the first place, we dont careeeee :DDD

            To check these cases, you need to refer to the following:
                SDM defined basic exit reason numbers:
                    -> Combined Volume Set of Intel速 64 and IA-32 Architectures Software Developers Manuals, Table C-1. Basic Exit Reasons (page 4285)
                VMX defined basic exit reason numbers:
                    -> vmx.h -> linux/arch/x86/include/uapi/asm/vmx.h
                             -> or the vmx.origin.h in my A3/source directory if you are a lazy ass :DDD (Joking! don't do it loool its not recommended)
                VMX enabled basic exit reason numbers:
                    -> vmx.c -> linux/arch/x86/include/kvm/vmx/vmx.c


1. Lets list it out the basic reason exit, so we can define the concrete range for 1st and 2nd validation check on basic exit reason number:
    see A3/screenshots/SDM-defined-exit-reasons[0~69][version-2022-09-30].jpg
        A3/screenshots/KVM-defined-exit-reasons[0-75][version-2022-06-08].jpg
        A3/screenshots/KVM-enabled-exit-reasons[title, 0~75][version-2022-10-05].jpg

    based on the exit info that we fetch from vmx.h and vmx.c, plus the info we have in SDM, we can have the following exit info in KVM:
        1. exit reason in KVM -> fetch from vmx.h
        2. exit# -> exit number -> -> fetch from SDM(page 4285), vmx.h
        3. SDM(D) -> defined in SDM -> fetch from SDM(page 4285)
        4. KVM(D) -> defined in KVM -> fetch from vmx.h
        5. KVM(E) -> enabled in KVM -> fetch from vmx.c

    exit reason in KVM                      exit#   SDM(D)  KVM(D)  KVM(E)  note
    // NULL                             N < 0       x       x       x       not defined in SDM (impossible since %ecx value type is is unsigned int 32)
    #define EXIT_REASON_EXCEPTION_NMI       0       o       o       o
    #define EXIT_REASON_EXTERNAL_INTERRUPT  1       o       o       o
    #define EXIT_REASON_TRIPLE_FAULT        2       o       o       o
    #define EXIT_REASON_INIT_SIGNAL         3       o       o       x       not enabled in KVM
    #define EXIT_REASON_SIPI_SIGNAL         4       o       o       x       not enabled in KVM
    // I/O system-management interrupt      5       o       x       x       not defined in KVM -> cannot be enabled in KVM
    // Other SMI                            6       o       x       x       not defined in KVM -> cannot be enabled in KVM
    #define EXIT_REASON_INTERRUPT_WINDOW    7       o       o       o
    #define EXIT_REASON_NMI_WINDOW          8       o       o       o
    #define EXIT_REASON_TASK_SWITCH         9       o       o       o
    #define EXIT_REASON_CPUID               10      o       o       o
    // GETSEC                               11      o       x       x       not defined in KVM -> cannot be enabled in KVM
    #define EXIT_REASON_HLT                 12      o       o       o
    #define EXIT_REASON_INVD                13      o       o       o
    #define EXIT_REASON_INVLPG              14      o       o       o
    #define EXIT_REASON_RDPMC               15      o       o       o
    #define EXIT_REASON_RDTSC               16      o       o       x       not enabled in KVM
    // RSM                                  17      o       x       x       not defined in KVM -> cannot be enabled in KVM
    #define EXIT_REASON_VMCALL              18      o       o       o
    #define EXIT_REASON_VMCLEAR             19      o       o       o
    #define EXIT_REASON_VMLAUNCH            20      o       o       o
    #define EXIT_REASON_VMPTRLD             21      o       o       o
    #define EXIT_REASON_VMPTRST             22      o       o       o
    #define EXIT_REASON_VMREAD              23      o       o       o
    #define EXIT_REASON_VMRESUME            24      o       o       o
    #define EXIT_REASON_VMWRITE             25      o       o       o
    #define EXIT_REASON_VMOFF               26      o       o       o
    #define EXIT_REASON_VMON                27      o       o       o
    #define EXIT_REASON_CR_ACCESS           28      o       o       o
    #define EXIT_REASON_DR_ACCESS           29      o       o       o
    #define EXIT_REASON_IO_INSTRUCTION      30      o       o       o
    #define EXIT_REASON_MSR_READ            31      o       o       o
    #define EXIT_REASON_MSR_WRITE           32      o       o       o
    #define EXIT_REASON_INVALID_STATE       33      o       o       x       not enabled in KVM
    #define EXIT_REASON_MSR_LOAD_FAIL       34      o       o       x       not enabled in KVM
    // NULL                                 35      x       x       x       not defined in SDM
    #define EXIT_REASON_MWAIT_INSTRUCTION   36      o       o       o
    #define EXIT_REASON_MONITOR_TRAP_FLAG   37      o       o       o
    // NULL                                 38      x       x       x       not defined in SDM
    #define EXIT_REASON_MONITOR_INSTRUCTION 39      o       o       o
    #define EXIT_REASON_PAUSE_INSTRUCTION   40      o       o       o
    #define EXIT_REASON_MCE_DURING_VMENTRY  41      o       o       o
    // NULL                                 42      x       x       x       not defined in SDM
    #define EXIT_REASON_TPR_BELOW_THRESHOLD 43      o       o       o
    #define EXIT_REASON_APIC_ACCESS         44      o       o       o
    #define EXIT_REASON_EOI_INDUCED         45      o       o       o
    #define EXIT_REASON_GDTR_IDTR           46      o       o       o
    #define EXIT_REASON_LDTR_TR             47      o       o       o
    #define EXIT_REASON_EPT_VIOLATION       48      o       o       o
    #define EXIT_REASON_EPT_MISCONFIG       49      o       o       o
    #define EXIT_REASON_INVEPT              50      o       o       o
    #define EXIT_REASON_RDTSCP              51      o       o       x       not enabled in KVM
    #define EXIT_REASON_PREEMPTION_TIMER    52      o       o       o
    #define EXIT_REASON_INVVPID             53      o       o       o
    #define EXIT_REASON_WBINVD              54      o       o       o
    #define EXIT_REASON_XSETBV              55      o       o       o
    #define EXIT_REASON_APIC_WRITE          56      o       o       o
    #define EXIT_REASON_RDRAND              57      o       o       o
    #define EXIT_REASON_INVPCID             58      o       o       o
    #define EXIT_REASON_VMFUNC              59      o       o       o
    #define EXIT_REASON_ENCLS               60      o       o       o
    #define EXIT_REASON_RDSEED              61      o       o       o
    #define EXIT_REASON_PML_FULL            62      o       o       o
    #define EXIT_REASON_XSAVES              63      o       o       x       not enabled in KVM
    #define EXIT_REASON_XRSTORS             64      o       o       x       not enabled in KVM
    // PCONFIG                              65      o       x       x       not defined in KVM -> cannot be enabled in KVM
    // SPP-related event                    66      o       x       x       not defined in KVM -> cannot be enabled in KVM
    #define EXIT_REASON_UMWAIT              67      o       o       x       not enabled in KVM
    #define EXIT_REASON_TPAUSE              68      o       o       x       not enabled in KVM
    // LOADIWKEY                            69      o       x       x       not defined in KVM -> cannot be enabled in KVM
    // NULL                             N > 69      x       x       x       not defined in SDM
    #define EXIT_REASON_BUS_LOCK            74      x       o       o       not defined in SDM(but defined and enabled in KVM)
    #define EXIT_REASON_NOTIFY              75      x       o       o       not defined in SDM(but defined and enabled in KVM)

    (Not important)
    A decade has been passed....just for checking these numbers!!!
    BRUHHHH, why cant they just say it or comment it when they implement it!! :CCC

    Okay lets summarizes it a little:
        The 1st invalid range for %ecx(not defined in SDM):
            -> N<0, N>69, 35, 38, 42
        The 2nd invalid range for %ecx(not defined/enabled in KVM):
            -> 3~6, 11, 16~17, 33~34, 51, 63~69
        The valid range for %ecx(defined in SDM and enabled in KVM):
            -> 0~2, 7~10, 12~15, 18~32, 36~37, 39~41, 43~50, 52~62

    In other words, we can have the following helper function to filter out the invalid exit numbers for us:
        // helper condition checking function for ecx value validation in SDM
        bool ecx_defined_in_sdm(u32 *ecx) {
            int lower_bound = 0;
            int upper_bound = 69;
            int sdm_not_defined_exit[] = {35, 38, 42};
            int length = (int)(sizeof(sdm_not_defined_exit) / sizeof(sdm_not_defined_exit[0]);
            int i;

            if (*ecx >= lower_bound && *ecx <= upper_bound) {
                for (i = 0; i < length; i++) {
                    if (*ecx == sdm_not_defined_exit[i]) {
                        return false;
                    }
                }
                return true;
            } else {
                return false;
            }

        }

        // helper condition checking function for ecx value validation in KVM
        bool ecx_enabled_in_vmx(u32 *ecx) {
            int vmx_not_enabled_exit[] = {3, 4, 5, 6, 11, 16, 17, 33, 34, 51, 63, 64, 65, 66, 67, 68, 69};
            int length = (int)(sizeof(vmx_not_enabled_exit) / sizeof(vmx_not_enabled_exit[0]);
            int i;

            for (i = 0; i < length; i++) {
                if (*ecx == vmx_not_enabled_exit[i]) {
                    return false;
                }
            }
            return true;
        }

    (CRITICAL)
    The above info are retried from :
        1. textbook Combined Volume Set of Intel速 64 and IA-32 Architectures Software Developers Manuals
        with version 09/30/2022
        2. vmx.h -> linux/arch/x86/include/uapi/asm/vmx.h with last commit in 05/24/2022.
        3. vmx.c -> linux/arch/x86/include/kvm/vmx/vmx.c with last commit in  10/05/2022.

    Therefore, when referencing my work, make sure to double-check the range of Basic Exit Reasons
    in the most up-to-date version of the textbook, vmx.h, vmx.c, as things might change! :d


2. We can also revisit the implementation of A2 to see what we can re-use to implement the leaf nodes required in A3:
        We can recall what we did to fulfill the requirement of A2:

        In linux/arch/x86/kvm/vmx/vmx.c, vmx_handle_exit(), we did:
                arch_atomic_inc(&total_exits_counter);
                    -> to update the total exit counter
                arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &total_cpu_cycles_counter);
                    -> to update the total cpu exit cycle

        Maybe we can do something similar to A2 to get A3 done...? Let's see: since A3 start to require us to update
        one specific type of exit counter and exit time cycle, we can do something like:
            extern atomic_t type_exits_counter[70];
            extern atomic64_t type_cpu_cycles_counter[70];

            arch_atomic_inc(&type_exits_counter[???]);
                -> to update the type-specific exit counter
            arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &type_cpu_cycles_counter[???]);
                -> to update the type-specific cpu exit cycle

        Cool, we are close, we now only need to figure out the correct index to fill in the ??? hole.

        But what should they be...? A3 already told us to read the value of %ecx to judge the exit type, but where can we
        read the value of %ecx?

        Well, to obtain the info of %ecx, we need to first access the info that stores in exit_reason.basic,
        and it can be derived from struct vmx:
            struct vcpu_vmx *vmx = to_vmx(vcpu);
            union vmx_exit_reason exit_reason = vmx->exit_reason;

        Do we have it ready in A2 so that we can simply use it...? Welp, No.

        Okay, what we did in A2 is actually quick and dirty: we did not care about the type of exits,
        and we just add 1 to the total exit counter and add exit time duration to the total exit
        cpu cycle time. We did not touch __vmx_handle_exit() as things can be done in vmx_handle_exit().

        However, we need to get the info in %ecx if we want to record exit count and cpu cycle time for one specific
        exit type, and the implementation we have in A2 cannot help us as we did not check the value of %ecx.
        In fact, since we only touched vmx_handle_exit() and did not touch __vmx_handle_exit(), we dont have the
        info of %ecx at all! :d

        Luckily, if we look at the implementation of __vmx_handle_exit(), we can notice that it has the pointer variable
        with struct vcpu_vmx which has all the info of vcpu for vmx usage:

        linux/arch/x86/kvm/vmx/vmx.c, __vmx_handle_exit():
        	struct vcpu_vmx *vmx = to_vmx(vcpu);
        	union vmx_exit_reason exit_reason = vmx->exit_reason;
        It is right there at the beginning of __vmx_handle_exit()! Now we can freely access the basic exit info in %ecx,
        which stores in exit_reason.basic.

        So our A3 type specified exit counter and cycle update will look the following:

        linux/arch/x86/kvm/vmx/vmx.c, __vmx_handle_exit():
            arch_atomic_inc(&type_exits_counter[exit_reason.basic]);
                -> to update the type-specific exit counter
            arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &type_cpu_cycles_counter[exit_reason.basic]);
                -> to update the type-specific cpu exit cycle

        Great, now we just need to refactor what we did in vmx.c -> vmx_handle_exit() and put it in __vmx_handle_exit() for A2
        (pay the technical debt we had in A2), and implement the new features for A3 in vmx.c -> __vmx_handle_exit() and
        cpuid.c -> kvm_emulate_cpuid()

        Also, to make our code more readable, we should implement our %ecx value validation check (discussed in step 39)
        in a more readable and maintainable way inside the cpuid.c:
            // helper condition checking function for ecx value validation in SDM
            bool ecx_defined_in_sdm(u32 *ecx) {
                return (*ecx >=0 && *ecx <= 69 && *ecx != 35 && *ecx != 38 && *ecx != 42);
            }
            // helper condition checking function for ecx value validation in VMX
            bool ecx_enabled_in_vmx(u32 *ecx) {
                return (*ecx != 5 && *ecx != 6 && *ecx != 11 && *ecx != 17 && *ecx != 65 && *ecx != 66 && *ecx != 69);
            }

        Okay! so our total work field is the following:
            linux/arch/x86/kvm/vmx/vmx.c:
                vmx_handle_exit(), __vmx_handle_exit()
            linux/arch/x86/kvm/cpuid.c:
                kvm_emulate_cpuid()
            linux/arch/x86/kvm/cpuid.h:
                declaration of helper functions:
                    -> bool ecx_defined_in_sdm(u32 *ecx);
                    -> bool ecx_enabled_in_vmx(u32 *ecx);


3. let's modify ~/linux/arch/x86/kvm/vmx/vmx.c first for A3 requirement:
    vmx.c:
        //extern global volatile int32 variable total_exits_counter (from cpuid.c)
        //for recording total number of exits (all types)
        extern atomic_t total_exits_counter;
        //extern global volatile int64 variable total_cpu_cycles_counter (from cpuid.c)
        //for recording total number of cpu cycles on exits (all types)
        extern atomic64_t total_cpu_cycles_counter;

        //extern global volatile int32 array variable type_exits_counter (from cpuid.c)
        //for recording total number of exits (type-specified)
        extern atomic_t type_exits_counter[70];
        //extern global volatile int64 array variable type_cpu_cycles_counter (from cpuid.c)
        //for recording total number of cpu cycles on exits (type-specified)
        extern atomic64_t type_cpu_cycles_counter[70];

        static int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)
        {
            struct vcpu_vmx *vmx = to_vmx(vcpu);
            union vmx_exit_reason exit_reason = vmx->exit_reason;
            u32 vectoring_info = vmx->idt_vectoring_info;
            u16 exit_handler_index;

            // local uint64_t variables for record the beginning and the ending of processor's time stamp counter
            uint64_t begin_time_stamp_counter, end_time_stamp_counter;
            // local int variable to store the return status of vmx handler exit function
            int exit_handler_status;
            ...
            ...
            exit_handler_index = array_index_nospec((u16)exit_reason.basic,
                                kvm_vmx_max_exit_handlers);
            if (!kvm_vmx_exit_handlers[exit_handler_index])
                goto unexpected_vmexit;

            // increase by 1 for every exit
            arch_atomic_inc(&total_exits_counter);

            // increase by 1 for current type-specified exit
            if (exit_reason.basic < 70) {
                arch_atomic_inc(&type_exits_counter[(int)exit_reason.basic]);
            }
            // record the beginning of cpu's time stamp counter
            begin_time_stamp_counter = rdtsc();

            // call the corresponding exit handler to handle the exit
            exit_handler_status = kvm_vmx_exit_handlers[exit_handler_index](vcpu);

            // record the ending of cpu's time stamp counter
            end_time_stamp_counter = rdtsc();

            // compute the current time stamp gap and add it to the cpu cycle time of total exits
            arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &total_cpu_cycles_counter);

            // compute the current time stamp gap and add it to the cpu cycle time of type-specified exit
            if (exit_reason.basic < 70) {
                arch_atomic64_add((end_time_stamp_counter - begin_time_stamp_counter), &type_cpu_cycles_counter[(int)exit_reason.basic]);
            }

            return exit_handler_status;
            ...
            ...
        }

4. then modify ~/linux/arch/x86/kvm/cpuid.c for A3 requirement:

    cpuid.c:
        //volatile int32 counter for recording total number of exits (all types), atomically initialize to 0
        atomic_t total_exits_counter = ATOMIC_INIT(0);
        //export the variable total_exits_counter so vmx.c can use it
        EXPORT_SYMBOL(total_exits_counter);

        //volatile int64 counter for recording total number of cpu cycles on exits (all types), atomically initialize to 0
        atomic64_t total_cpu_cycles_counter = ATOMIC64_INIT(0);
        //export the variable total_cup_cycles_counter so vmx.c can use it
        EXPORT_SYMBOL(total_cpu_cycles_counter);

        //volatile int64 counter for recording total number of exits (type-specified), all initialize to 0 internally
        atomic_t type_exits_counter[70];
        //export the variable type_exits_counter so vmx.c can use it
        EXPORT_SYMBOL(type_exits_counter);

        //volatile int64 counter for recording total number of cpu cycles on exits (type-specified), atomically initialize to 0
        atomic64_t type_cpu_cycles_counter[70];
        //export the variable type_cpu_cycles_counter so vmx.c can use it
        EXPORT_SYMBOL(type_cpu_cycles_counter);

        int kvm_emulate_cpuid(struct kvm_vcpu *vcpu)
        {
            u32 eax, ebx, ecx, edx;
            // u32 variable for copying the value of ECX in case %eax = 0x4FFFFFFE and %eax = 0x4FFFFFFF
            u32 ecx_copy;
            // u64 variable for copying the value of exit counter from atomic64_read() in case %eax = 0x4FFFFFFD and %eax = 0x4FFFFFFF
            u64 cycle_counter;

            if (cpuid_fault_enabled(vcpu) && !kvm_require_cpl(vcpu, 0))
                return 1;

            eax = kvm_rax_read(vcpu);
            ecx = kvm_rcx_read(vcpu);

            // check special new CPUID leaf that defined in A2
            switch(eax) {
                // case %eax = 0x4FFFFFFC
                case 0x4FFFFFFC:
                    printk(KERN_INFO "### CPUID(0x4FFFFFFC) -> ");
                    eax = arch_atomic_read(&total_exits_counter);
                    printk(KERN_INFO "### Total Exits = %u", eax);
                    //printk(KERN_INFO "### Total Exits in EAX = %u", eax);
                    break;

                // case %eax = 0x4FFFFFFD
                case 0x4FFFFFFD:
                    printk(KERN_INFO "### CPUID(0x4FFFFFFD) -> ");
                    cycle_counter = atomic64_read(&total_cpu_cycles_counter);
                    //the high 32 bits of the total time spent processing all exits store in %ebx
                    ebx = (cycle_counter >> 32);;
                    //the low 32 bits of the total time spent processing all exits store in %ecx
                    ecx = (cycle_counter & 0xFFFFFFFF);
                    printk(KERN_INFO "### Total CPU Exit Cycle Time = %llu", cycle_counter);
                    //printk(KERN_INFO "### Total CPU Exit Cycle Time(hi) in EBX = %u", ebx);
                    //printk(KERN_INFO "### Total CPU Exit Cycle Time(lo) in ECX = %u", ecx);
                    break;

                // case %eax = 0x4FFFFFFE
                case 0x4FFFFFFE:
                    printk(KERN_INFO "### CPUID(0x4FFFFFFE) -> ECX = %u", ecx);
                    // check if the value of %ecx is defined in SDM
                    if (ecx_defined_in_sdm(&ecx)) {
                        // check if the value of %ecx is enable in VMX
                        if (ecx_enabled_in_vmx(&ecx)) {
                            ecx_copy = ecx;
                            eax = arch_atomic_read(&type_exits_counter[(int)ecx]);
                            printk(KERN_INFO "### Type %u Exit Count = %u", ecx_copy, eax);
                            //printk(KERN_INFO "### Type %u Total Exits in EAX = %u", ecx_copy, eax);
                        } else {
                            printk(KERN_INFO "### Exit Number in ECX Defined in SDM But Not Enabled in KVM ");
                            eax = 0; ebx = 0; ecx = 0; edx = 0;
                        }
                    } else {
                        printk(KERN_INFO "### Exit Number in ECX Not Defined in SDM ");
                        eax = 0; ebx = 0; ecx = 0; edx = 0xFFFFFFFF;
                    }
                    break;

                // case %eax = 0x4FFFFFFF
                case 0x4FFFFFFF:
                    printk(KERN_INFO "### CPUID(0x4FFFFFFF) -> ECX = %u", ecx);
                    // check if the value of %ecx is defined in SDM
                    if (ecx_defined_in_sdm(&ecx)) {
                        // check if the value of %ecx is enable in VMX
                        if (ecx_enabled_in_vmx(&ecx)) {
                            ecx_copy = ecx;
                            cycle_counter = atomic64_read(&type_cpu_cycles_counter[(int)ecx]);
                            //the high 32 bits of the total time spent processing all exits store in %ebx
                            ebx = (cycle_counter >> 32);;
                            //the low 32 bits of the total time spent processing all exits store in %ecx
                            ecx = (cycle_counter & 0xFFFFFFFF);
                            printk(KERN_INFO "### Type %u CPU Exit Cycle Time = %llu", ecx_copy, cycle_counter);
                            //printk(KERN_INFO "### Type %u CPU Exit Cycle Time(hi) in EBX = %u", ecx_copy, ebx);
                            //printk(KERN_INFO "### Type %u CPU Exit Cycle Time(lo) in ECX = %u", ecx_copy, ecx);
                        } else {
                            printk(KERN_INFO "### Exit Number in ECX Defined in SDM But Not Enabled in KVM ");
                            eax = 0; ebx = 0; ecx = 0; edx = 0;
                        }
                    } else {
                            printk(KERN_INFO "### Exit Number in ECX Not Defined in SDM ");
                            eax = 0; ebx = 0; ecx = 0; edx = 0xFFFFFFFF;
                    }
                    break;

                // default case for all other %eax value
                default:
                    kvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx, false);
            }

            kvm_rax_write(vcpu, eax);
            kvm_rbx_write(vcpu, ebx);
            kvm_rcx_write(vcpu, ecx);
            kvm_rdx_write(vcpu, edx);
            return kvm_skip_emulated_instruction(vcpu);
        }

        // helper condition checking function for ecx value validation in SDM
        bool ecx_defined_in_sdm(u32 *ecx) {
            int lower_bound = 0;
            int upper_bound = 69;
            int sdm_not_defined_exit[] = {35, 38, 42};
            int length = (int)(sizeof(sdm_not_defined_exit) / sizeof(sdm_not_defined_exit[0]);
            int i;

            if (*ecx >= lower_bound && *ecx <= upper_bound) {
                for (i = 0; i < length; i++) {
                    if (*ecx == sdm_not_defined_exit[i]) {
                        return false;
                    }
                }
                return true;
            } else {
                return false;
            }

        }

        // helper condition checking function for ecx value validation in KVM
        bool ecx_enabled_in_vmx(u32 *ecx) {
            int vmx_not_enabled_exit[] = {3, 4, 5, 6, 11, 16, 17, 33, 34, 51, 63, 64, 65, 66, 67, 68, 69};
            int length = (int)(sizeof(vmx_not_enabled_exit) / sizeof(vmx_not_enabled_exit[0]);
            int i;

            for (i = 0; i < length; i++) {
                if (*ecx == vmx_not_enabled_exit[i]) {
                    return false;
                }
            }
            return true;
        }

5. finally, modify ~/linux/arch/x86/kvm/cpuid.h to add declaration for the helper functions we defined in cpuid.c:

    cpuid.h:
        ...
        extern u32 kvm_cpu_caps[NR_KVM_CPU_CAPS] __read_mostly;

        // Assignment 3 Modification ->
        // declaration for helper functions defined in cpuid.c
        bool ecx_defined_in_sdm(u32 *ecx);
        bool ecx_enabled_in_vmx(u32 *ecx);

        void kvm_set_cpu_caps(void);
        ...

6. go back to the top level of ~/linux to build and install the modules again, then install the kernel:
        make -j <your-vm-cpu-total-core-number> modules
        sudo make -j <your-vm-cpu-total-core-number> INSTALL_MOD_STRIP=1 modules_install && make
        sudo lsmod | grep kvm
        sudo rmmod kvm_intel
        sudo rmmod kvm
        sudo modprobe kvm
        sudo modprobe kvm_intel
        sudo lsmod | grep kvm
        sudo kvm-ok
        sudo reboot

7. now we can perform our A3 exit handling testing on the inner-VM:
    Go to https://remotedesktop.google.com/headless
    and connect to your VM instance
    (CRITICAL) Log in using the same account which you use for your GCP VM
    uname -a
        to make sure you connect to the right L1 VM instance
    sudo virt-manager
        to run and open the GUI for L2 VM for testing

    A3-test.c:
        printf("\n-----Test Leaf Node CPUID(0x4FFFFFFC)-----\n\n");
        eax = 0x4FFFFFFC;
        __cpuid(&eax, &ebx, &ecx, &edx);
        printf("CPUID(0x4FFFFFFC), All Type Total Exit Counter = %u \n", eax);
        printf("EAX = %u  EBX = %u ECX = %u EDX = %u \n", eax, ebx, ecx, edx);


        printf("\n-----Test Leaf Node CPUID(0x4FFFFFFD)-----\n\n");
        eax = 0x4FFFFFFD;
        __cpuid(&eax, &ebx, &ecx, &edx);
        cycle_time = (unsigned long long) ebx << 32 | ecx;
        printf("CPUID(0x4FFFFFFD), All Type Total Exit Cycles = %llu \n", cycle_time);
        printf("EAX = %u  EBX = %u ECX = %u EDX = %u \n", eax, ebx, ecx, edx);

        /*
        The 1st invalid range for %ecx(not defined in SDM):
            -> N<0, N>69, 35, 38, 42
        The 2nd invalid range for %ecx(not defined/enabled in KVM):
            -> 3~6, 11, 16~17, 33~34, 51, 63~69
        The valid range for %ecx(defined in SDM and enabled in KVM):
            -> 0~2, 7~10, 12~15, 18~32, 36~37, 39~41, 43~50, 52~62
        (CRITICAL)
        The above basic exit reason index info are retried from :
            1. textbook Combined Volume Set of Intel速 64 and IA-32 Architectures Software Developers Manuals
            with version 09/30/2022
            2. vmx.h -> linux/arch/x86/include/uapi/asm/vmx.h with last commit in 05/24/2022.
            3. vmx.c -> linux/arch/x86/include/kvm/vmx/vmx.c with last commit in  10/05/2022.
        */

        printf("\n-----Test Leaf Node CPUID(0x4FFFFFFE)-----\n\n");
        for(i = 0; i < 75; i++) {
            eax = 0x4FFFFFFE;
            ecx = i;
            ecx_copy = ecx;
            __cpuid(&eax, &ebx, &ecx, &edx);
            printf("CPUID(0x4FFFFFFE), Type %u Total Exit Counter = %u \n", ecx_copy, eax);
            printf("EAX = %u  EBX = %u ECX = %u EDX = %u \n", eax, ebx, ecx, edx);
        }

        printf("\n-----Test Leaf Node CPUID(0x4FFFFFFF)-----\n\n");
        for(i = 0; i < 75; i++) {
            eax = 0x4FFFFFFF;
            ecx = i;
            ecx_copy = ecx;
            __cpuid(&eax, &ebx, &ecx, &edx);
                cycle_time = (unsigned long long) ebx << 32 | ecx;
            printf("CPUID(0x4FFFFFFF), Type %u Total Exit Cycles = %llu \n", ecx_copy, cycle_time);
            printf("EAX = %u  EBX = %u ECX = %u EDX = %u \n", eax, ebx, ecx, edx);
        }


    In L2 VM:
        make
        make run

    A3-test result:
        see A3/screenshots/VM-L2-A3-test-result-E-[0~74].jpg
            A3/screenshots/VM-L2-A3-test-result-F-[0~74].jpg
            A3/screenshots/VM-L2-A3-test-result-statics-[1st][0~74].jpg


8. we can verify our A3-test result on our outer L1 VM as well using command dmesg:

    In L1 VM:
        sudo dmesg

    dmesg result:
        see A3/screenshots/VM-L1-demsg-for-A3-test-E-[0~74].jpg
            A3/screenshots/VM-L1-demsg-for-A3-test-F-[0~74].jpg


9. lets analyze the A3 result and see what is going on here:
    Since our A3 test cases ecx value range is [0, 74], it covered all 3 cases:
        The 1st invalid range for %ecx(not defined in SDM):
            -> N<0, N>69, 35, 38, 42
        The 2nd invalid range for %ecx(not defined/enabled in KVM):
            -> 3~6, 11, 16~17, 33~34, 51, 63~69
        The valid range for %ecx(defined in SDM and enabled in KVM):
            -> 0~2, 7~10, 12~15, 18~32, 36~37, 39~41, 43~50, 52~62

    Lets analyze the result from A3 test and focusing on the ones that is:
        1.invalid
            -> to check our A3 implementations on handling error
        2.valid AND has positive exit counter and cycles
            -> to see which type of the exit has the highest/lowest initial/increment value in exit counter/cycles/performance ratio(cycles/exit)

    From L2 A3-test result and L1 dmesg info we can confirm that all invalid cases are handled correctly! :D

    From L2 A3-test result section 'Statics Overview For Each Basic Exit' we can see that:
    only exit type 0, 10, 18, 28, 29, 30, 31, 46, 47, 48, 54, 55 are triggered during the L2 nested virtualization
    the rest did not get triggered and thus no info available for us to analyze

    Also, a full VM boot entails:
    1st run of A3-test after boost -> total 912798 exits with total 13052862220 cycle times

    The complete result list of the 1st A3-test run goes as follows:
        exit number      exit reason                    exit counter        exit cycles             cycles/exit
        0                EXIT_REASON_EXCEPTION_NMI      20263               3260689866              160918
        10               EXIT_REASON_CPUID              212161              247195426               1165
        18               EXIT_REASON_VMCALL             625                 220815398               353304
        28               EXIT_REASON_CR_ACCESS          33687               48861678                1450
        29               EXIT_REASON_DR_ACCESS          4                   37748                   9437
        30               EXIT_REASON_IO_INSTRUCTION     153953              229820312               1492
        31               EXIT_REASON_MSR_READ           872                 1565926                 1795
        46               EXIT_REASON_GDTR_IDTR          13                  353768                  27212
        47               EXIT_REASON_LDTR_TR            6                   205794                  34299
        48               EXIT_REASON_EPT_VIOLATION      491216              9043813744              18411
        54               EXIT_REASON_WBINVD             5                   4894                    978
        55               EXIT_REASON_XSETBV             5                   135456                  27091

    we can see that:
        -> exit type 48 EXIT_REASON_EPT_VIOLATION has the highest type-specified total exit counter
            -> it happens the most frequent
        -> exit type 29 EXIT_REASON_DR_ACCESS has the lowest type-specified total exit counter
            -> it happens the least frequent (among the ones that actually happens)
        -> exit type 48 EXIT_REASON_EPT_VIOLATION has the highest type-specified total exit cycles
            -> it takes the most total cpu cycle time
        -> exit type 54 EXIT_REASON_WBINVD has the lowest type-specified total exit cycles
            -> it takes the least total cpu cycle time (among the ones that actually happens)
        -> exit type 18 EXIT_REASON_VMCALL has the highest cycles/exit ratio
            -> it is most time consuming when handling
        -> exit type 54 EXIT_REASON_WBINVD has the lowest cycles/exit ratio
            -> it is least time consuming when handling

   let VM run for a while and trigger more exits before we run the 2nd round of A3-test...

   (10-15 minutes passed)

   now we need to run A3-test again and see how these exit statics changes over time:

   2nd run of A3-test after boost -> total 929620 exits with total 13250866844 cycle times

   The complete result list of the 1st A3-test run goes as follows:
        exit number      exit reason                    exit counter        exit cycles             cycles/exit
        0                EXIT_REASON_EXCEPTION_NMI      20263               3260689866              160918
        10               EXIT_REASON_CPUID              214382(+2221)       250819906(+3624480)     1169(+4)
        18               EXIT_REASON_VMCALL             1036(+411)          34688202(+125672804)    334448(-18856)
        28               EXIT_REASON_CR_ACCESS          33687               48861678                1450
        29               EXIT_REASON_DR_ACCESS          4                   37748                   9437
        30               EXIT_REASON_IO_INSTRUCTION     158565(+4612)       247738590(+17918278)    1562(+70)
        31               EXIT_REASON_MSR_READ           10432(+9560)        24211158(+22634232)     2320(+525)
        46               EXIT_REASON_GDTR_IDTR          13                  353768                  27212
        47               EXIT_REASON_LDTR_TR            6                   205794                  34299
        48               EXIT_REASON_EPT_VIOLATION      491234(+18)         9071955366(+28141622)   18467(+56)
        54               EXIT_REASON_WBINVD             5                   4894                    978
        55               EXIT_REASON_XSETBV             5                   135456                  27091

    we can see that:
        -> exit type 0, 28, 29, 46, 47, 54, 55 stays and does not have any increment
            -> they seems to be the ones that rarely trigger after the VM is fully boosted
        -> exit type 31 EXIT_REASON_MSR_READ has the highest increment on type-specified total exit counter
            -> over time it will happens more and more frequent
        -> exit type 48 EXIT_REASON_EPT_VIOLATION has the lowest increment on type-specified total exit counter
            -> over time it will happens less and less frequent (among the ones that actually has increment)
        -> exit type 18 EXIT_REASON_VMCALL has the highest increment in type-specified total exit cycles
            -> it increase the most mainly due to high cycles/exit ratio, so it is more sensitive to exit increments.
        -> exit type 10 EXIT_REASON_CPUID has the lowest increment in type-specified total exit cycles
            -> it increase the least mainly due to low cycles/exit ratio, so it is less sensitive to exit increments.
        -> exit type 18 EXIT_REASON_VMCALL has the highest delta in cycles/exit ratio
            -> again, due to high cycles/exit ratio, the re-computed value more likely to be changed when exit counter changes
        -> exit type 10 EXIT_REASON_CPUID has the lowest delta in cycles/exit ratio
            -> again, due to low cycles/exit ratio, the re-computed value more likely to stay the same even exit counter changes

10. now we have concrete answers to the A3 instructions:
        1. Does the number of exits increase at a stable rate?
            -> No, some of the exits increase, some of them stay the same. Among the ones that increase,
                they have different increment ratio depends on the exit type.
        2. Are there more exits performed during certain VM operations?
            -> Yes, for example, EXIT_REASON_CPUID(10), EXIT_REASON_IO_INSTRUCTION(30), EXIT_REASON_MSR_READ(31), etc.
        3. Approximately how many exits does a full VM boot entail?
            -> It entails total 912798 exits with total 13052862220 cycle times.
        4. Of the exit types defined in the SDM, which are the most frequent? Least?
            -> EXIT_REASON_EPT_VIOLATION(48) happens the most frequent, EXIT_REASON_DR_ACCESS(29) happens the least frequent;
            EXIT_REASON_MSR_READ(31) has the highest increment over time, EXIT_REASON_EPT_VIOLATION(48) has the lowest increment over time,


Conclusion:
   Thanks to A3, we now have a very clear picture of all the SDM-defined and KVM-enabled basic exit types and their
   corresponding initial/increment value in exit counter/cycles/performance ratio(cycles/exit), so we know which one
   to pay close attention to when modifying/optimizing our hypervisor so that our VMs that run on top of it can have
   the least performance(cpu cycle time) overhead.

   Throughout the assignments, we gain hands-on experiences in CPU MSRs Discovery, Nested Virtualization, Kernel Modification, and adding
   new CPUID leaf nodes to the KVM hypervisor to empower it with new features. Many thanks to Prof. Mike Larkin and
   GCP Education Team! We can study Virtualization Technologies with ease and use powerful GCP VMs with no cost all because of them.

   Okay, that's about it, see you around, my friend. ;]


Postscript:
   I hope my guides and the assignment log-books actually helped you to study these Virtualization Technologies topics :D,
   and I encourage you to do the same(if you feel like it), so the students that came after us can learn them without misery
   (feeling lost, don't know what to do, stuck all day, etc.), which is really unnecessary and can be avoided most of the time.

   I care because I am once in their shoes, so I know how painful and helpless it could be, epically I know I keep failing
   not because I am dumb (okay maybe a bit) but only because of lacking domain-specific knowledge and experience.
   You should know it also applies to you and everyone else. Nobody knows everything at the first place. We all need to learn,
   and no man is above a new lesson. During the hard times of learning a new lesson, just how great it could be
   if someone could be there for us, show us the way, and accompany us through hardship, right? ;D

   Luckily, some people(or I should call them heroes!) once be there for me during my hardest time, like Qingwei Zen, Jack Gong,
   and many others. The kindness and courage they pass down on me enable me to be there for you, and it would be great
   if you could be there for others in the future.

   May the force and courage be with you.




